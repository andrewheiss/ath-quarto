{
  "hash": "1cf0bf43228f9d5a2a77f6e70b8b030a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Manually generate predicted values for logistic regression with matrix multiplication in R\"\ndate: 2023-08-15\ndescription: \"This is like basic stats stuff, but I can never remember how to do it—here's how to use matrix multiplication to replicate the results of `predict()`\"\nimage: social-image.png\ntwitter-card:\n  image: \"social-image.png\"\nopen-graph:\n  image: \"social-image.png\"\ncategories:\n  - r\n  - statistics\n  - regression\ndoi: 10.59350/qba9a-b3561\ncitation: true\n---\n\n\n\nIn a project I'm working on, I need to generate predictions from a logistic regression model. That's typically a really straightforward task—we can just use `predict()` to plug a dataset of values into a model, which will spit out predictions either on the (gross, uninterpretable) log odds scale or on the (nice, interpretable) percentage-point scale.^[And for pro-level predictions, use `predictions()` from [{marginaleffects}](https://marginaleffects.com/chapters/predictions.html).]\n\nHowever, in this project I cannot use `predict()`—I'm working with a big matrix of posterior coefficient draws from a Bayesian model fit with raw Stan code, so there's no special `predict()` function that will work. Instead, I need to use matrix multiplication and manually multiply a matrix of new data with a vector of slopes from the model. \n\nI haven't had to matrix multiply coefficients with data since my first PhD stats class back in 2012 and I've completely forgotten how. \n\nI created this little guide as a reference for myself, and I figured it'd probably be useful for others, so up on the blog it goes ([see the introduction to this post for more about my philosophy of public work](https://www.andrewheiss.com/blog/2022/05/20/marginalia/index.html)).\n\n## Example 1: Logistic regression model with an intercept and slopes\n\nHere's a basic regression model where we predict if a penguin is a Gentoo based on its bill length and body mass. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n## \n## Attaching package: 'palmerpenguins'\n## The following objects are masked from 'package:datasets':\n## \n##     penguins, penguins_raw\n\npenguins <- penguins |> \n  tidyr::drop_na(sex) |> \n  dplyr::mutate(is_gentoo = species == \"Gentoo\")\n\nmodel <- glm(\n  is_gentoo ~ bill_length_mm + body_mass_g,\n  data = penguins,\n  family = binomial(link = \"logit\")\n)\n```\n:::\n\n\nWe can generate predicted values across different three different values of bill length: 40 mm, 44 mm, and 48 mm, holding body mass constant at the average (4207 g):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_to_plug_in <- expand.grid(\n  bill_length_mm = c(40, 44, 48),\n  body_mass_g = mean(penguins$body_mass_g)\n)\ndata_to_plug_in\n##   bill_length_mm body_mass_g\n## 1             40        4207\n## 2             44        4207\n## 3             48        4207\n```\n:::\n\n\nWe can feed this little dataset into the model using `predict()`, which can generate predictions as log odds (`type = \"link\"`) or probabilities (`type = \"response\"`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredict(model, newdata = data_to_plug_in, type = \"link\")\n##      1      2      3 \n## -2.097 -1.741 -1.385\npredict(model, newdata = data_to_plug_in, type = \"response\")\n##      1      2      3 \n## 0.1094 0.1492 0.2002\n```\n:::\n\n\nYay, nice and easy.\n\nHere's how to do the same thing with manual matrix multiplication:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the coefficients\n(coefs <- coef(model))\n##    (Intercept) bill_length_mm    body_mass_g \n##     -32.401514       0.088906       0.006358\n\n# Split intercept and slope coefficients into separate objects\n(intercept <- coefs[1])\n## (Intercept) \n##       -32.4\n(slopes <- coefs[-1])\n## bill_length_mm    body_mass_g \n##       0.088906       0.006358\n\n# Convert the data frame of new data into a matrix\n(data_to_plug_in_mat <- as.matrix(data_to_plug_in))\n##      bill_length_mm body_mass_g\n## [1,]             40        4207\n## [2,]             44        4207\n## [3,]             48        4207\n\n# Matrix multiply the new data with the slope coefficients, then add the intercept\n(log_odds <- as.numeric((data_to_plug_in_mat %*% slopes) + intercept))\n## [1] -2.097 -1.741 -1.385\n\n# Convert to probability scale\nplogis(log_odds)\n## [1] 0.1094 0.1492 0.2002\n```\n:::\n\n\nThe results are the same as `predict()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredict(model, newdata = data_to_plug_in, type = \"link\")\n##      1      2      3 \n## -2.097 -1.741 -1.385\nlog_odds\n## [1] -2.097 -1.741 -1.385\n\npredict(model, newdata = data_to_plug_in, type = \"response\")\n##      1      2      3 \n## 0.1094 0.1492 0.2002\nplogis(log_odds)\n## [1] 0.1094 0.1492 0.2002\n```\n:::\n\n\n\n## Example 2: Logistic regression model with a categorical predictor and no intercept\n\nThis gets a little more complex when working with categorical predictors, especially if you've omitted the intercept term. For instance, in the data I'm working with, we have a model that looks something like this, with `0` added as a term to suppress the intercept and give separate coefficients for each of the levels of `sex`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_categorical <- glm(\n  is_gentoo ~ 0 + sex + bill_length_mm + body_mass_g,\n  data = penguins,\n  family = binomial(link = \"logit\")\n)\ncoef(model_categorical)\n##      sexfemale        sexmale bill_length_mm    body_mass_g \n##      -75.68237      -89.88199        0.03387        0.01831\n```\n:::\n\n\nWhen using `predict()`, we don't have to do anything special with this intercept-free model. We can plug in a dataset with different variations of predictors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_to_plug_in_cat <- expand.grid(\n  sex = c(\"female\", \"male\"),\n  bill_length_mm = c(40, 44, 48),\n  body_mass_g = mean(penguins$body_mass_g)\n)\ndata_to_plug_in_cat\n##      sex bill_length_mm body_mass_g\n## 1 female             40        4207\n## 2   male             40        4207\n## 3 female             44        4207\n## 4   male             44        4207\n## 5 female             48        4207\n## 6   male             48        4207\n\npredict(model_categorical, newdata = data_to_plug_in_cat, type = \"link\")\n##       1       2       3       4       5       6 \n##   2.707 -11.493   2.842 -11.357   2.978 -11.222\npredict(model_categorical, newdata = data_to_plug_in_cat, type = \"response\")\n##         1         2         3         4         5         6 \n## 9.374e-01 1.020e-05 9.449e-01 1.169e-05 9.516e-01 1.338e-05\n```\n:::\n\n\nIf we want to do this manually, we have to create a matrix version of `data_to_plug_in_cat` that has separate columns for `sexfemale` and `sexmale`. We can't just use `as.matrix(data_to_plug_in_cat)`, since that only has a single column for `sex` (and because that column contains text, it forces the rest of the matrix to be text, which makes it so we can't do math with it anymore):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.matrix(data_to_plug_in_cat)\n##      sex      bill_length_mm body_mass_g\n## [1,] \"female\" \"40\"           \"4207\"     \n## [2,] \"male\"   \"40\"           \"4207\"     \n## [3,] \"female\" \"44\"           \"4207\"     \n## [4,] \"male\"   \"44\"           \"4207\"     \n## [5,] \"female\" \"48\"           \"4207\"     \n## [6,] \"male\"   \"48\"           \"4207\"\n```\n:::\n\n\nInstead, we can use `model.matrix()` to create a design matrix—also called a dummy-encoded matrix^[Though we should probably quit using the word \"dummy\" because of its ableist connotations—see [Google's developer documentation style guide for alternatives](https://developers.google.com/style/word-list#dummy-variable).] or a one-hot encoded matrix—which makes columns of 0s and 1s for each of the levels of `sex`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_to_plug_in_cat_mat <- model.matrix(\n  ~ 0 + ., data = data_to_plug_in_cat\n)\ndata_to_plug_in_cat_mat\n##   sexfemale sexmale bill_length_mm body_mass_g\n## 1         1       0             40        4207\n## 2         0       1             40        4207\n## 3         1       0             44        4207\n## 4         0       1             44        4207\n## 5         1       0             48        4207\n## 6         0       1             48        4207\n## attr(,\"assign\")\n## [1] 1 1 2 3\n## attr(,\"contrasts\")\n## attr(,\"contrasts\")$sex\n## [1] \"contr.treatment\"\n```\n:::\n\n\nWe can now do math with this matrix. Since we don't have an intercept term, we don't need to create separate objects for the slopes and intercepts and can matrix multiply the new data matrix with the model coefficients:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the coefficients\n(coefs_cat <- coef(model_categorical))\n##      sexfemale        sexmale bill_length_mm    body_mass_g \n##      -75.68237      -89.88199        0.03387        0.01831\n\n# Matrix multiply the newdata with the slope coefficients\n(log_odds_cat <- as.numeric(data_to_plug_in_cat_mat %*% coefs_cat))\n## [1]   2.707 -11.493   2.842 -11.357   2.978 -11.222\n\n# Convert to probability scale\nplogis(log_odds_cat)\n## [1] 9.374e-01 1.020e-05 9.449e-01 1.169e-05 9.516e-01 1.338e-05\n```\n:::\n\n\nThe results are the same!\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredict(model_categorical, newdata = data_to_plug_in_cat, type = \"link\")\n##       1       2       3       4       5       6 \n##   2.707 -11.493   2.842 -11.357   2.978 -11.222\nlog_odds_cat\n## [1]   2.707 -11.493   2.842 -11.357   2.978 -11.222\n\npredict(model_categorical, newdata = data_to_plug_in_cat, type = \"response\")\n##         1         2         3         4         5         6 \n## 9.374e-01 1.020e-05 9.449e-01 1.169e-05 9.516e-01 1.338e-05\nplogis(log_odds_cat)\n## [1] 9.374e-01 1.020e-05 9.449e-01 1.169e-05 9.516e-01 1.338e-05\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}