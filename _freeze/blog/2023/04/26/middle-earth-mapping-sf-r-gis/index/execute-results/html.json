{
  "hash": "3c8d655bc08271745d6d063e96053e83",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Making Middle Earth maps with R\"\ndate: 2023-04-26\ndescription: \"Explore Tolkien's Middle Earth with R-based GIS tools, including {ggplot2} and {sf}\"\nimage: index_files/figure-html/shire-zoomed-in-fancy-1.png\ntwitter-card: \n    image: \"index_files/figure-html/shire-zoomed-in-fancy-1.png\"\nopen-graph: \n    image: \"index_files/figure-html/shire-zoomed-in-fancy-1.png\"\ncategories:\n  - r\n  - tidyverse\n  - ggplot\n  - gis\n  - maps\n  - nerdery\nformat:\n  html: \n    code-fold: show\ndoi: 10.59350/ccrtd-z3s22\ncitation: true\n---\n\n\n\n\nI've taught a course on data visualization with R since 2017, and it's become one of my more popular classes, especially since [it's all available asynchronously online](https://datavizs22.classes.andrewheiss.com/) with hours of Creative Commons-licensed videos and materials. One of the most popular sections of the class (as measured by my server logs and by how often I use it myself) is [a section on GIS-related visualization](https://datavizs22.classes.andrewheiss.com/example/12-example/), or how to work with maps in {ggplot2}. Nowadays, since the advent of the [{sf} package](https://r-spatial.github.io/sf/), I find that making maps with R is incredibly easy and fun.\n\nI'm also a huge fan of J. R. R. Tolkien and his entire [Legendarium](https://en.wikipedia.org/wiki/Tolkien%27s_legendarium) (as evidenced by [my previous blog post here](https://www.andrewheiss.com/blog/2023/03/21/aragorn-dunedan-numenorean-simulation/) simulating Aragorn's human-scale age based on an obscure footnote in Tolkien's writings about Númenor).\n\nBack in 2020, as I was polishing up my data visualization course page on visualizing spatial data, I stumbled across [a set of shapefiles for Middle Earth](https://github.com/jvangeld/ME-GIS), meaning that it was possible to use R and ggplot to make maps of Tolkien's fictional world. I whipped up a quick example and [tweeted about it](https://twitter.com/andrewheiss/status/1291380121069330432) back then, but then kind of forgot about it.\n\nWith Twitter dying, and with my recent read of *The Fall of Númenor*, Middle Earth maps have been on my mind again, so I figured I'd make a more formal didactic blog post about how to make and play with these maps. So consider this blog post a fun little playground for learning more about doing GIS work with {sf} and ggplot, and learn some neat data visualization tricks along the way.\n\nLet's put the R in \"J. R. R.\"\n\n\n# Lightning quick overview of {sf} and shapefiles\n\n::: {.callout-note}\nThis is a wildly brief intro to the {sf} package. For more details, see my [data visualization lesson on visualizing space](https://datavizs22.classes.andrewheiss.com/example/12-example/), as well as the free [*Spatial Data Science*](https://r-spatial.org/book/) and [Geocomputation with R](https://r.geocompx.org/) books.\n:::\n\nThanks to the magic of the [{sf} package](https://r-spatial.github.io/sf/) (\"sf\" = [\"simple features\"](https://en.wikipedia.org/wiki/Simple_Features)), working with geographic (or GIS) data in R is really really straightforward and fun. \n\nGeographic data is a lot more complex than regular tabular spreadsheet-like data, since it includes information about points (latitude, longitude), paths (a bunch of connected latitudes and longitudes) and areas (a bunch of connected latitudes and longitudes that form a complete shape). Additionally, it has to keep track of units and distances and map projections (or methods for [flattening parts of a round globe onto a two-dimensional surface](https://www.youtube.com/watch?v=kIID5FDi2JQ)). This kind of data is often stored in [shapefile format](https://en.wikipedia.org/wiki/Shapefile) (though there are alternatives like [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON)), which consist of multiple files. For instance, here's what the 2022 US Census's shapefile for US states looks like when unzipped:\n\n```text\ncb_2022_us_state_20m\n├── cb_2022_us_state_20m.cpg\n├── cb_2022_us_state_20m.dbf\n├── cb_2022_us_state_20m.prj\n├── cb_2022_us_state_20m.shp\n├── cb_2022_us_state_20m.shp.ea.iso.xml\n├── cb_2022_us_state_20m.shp.iso.xml\n└── cb_2022_us_state_20m.shx\n```\n\nIt has 7 different files, each with different purposes! Fortunately, it's easy to read all these in with {sf}. Feed the name of the main `.shp` file to `read_sf()` and it'll handle all the other secondary files (like `.dbf` and `.shx` and `.prj`).\n\nHere I've downloaded the [US Census's 1:20,000,000 Cartographic Boundary File shapefile](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html) and put it in a folder named `data`. We can load it into R with `read_sf()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(sf)\n\n# https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html\nus_states <- read_sf(\"data/cb_2022_us_state_20m/cb_2022_us_state_20m.shp\")\n\n# Just show some of the columns\nus_states %>% \n  select(STATEFP, STUSPS, NAME, geometry)\n## Simple feature collection with 52 features and 3 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -179 ymin: 17.9 xmax: 180 ymax: 71.4\n## Geodetic CRS:  NAD83\n## # A tibble: 52 × 4\n##    STATEFP STUSPS NAME                                                                                      geometry\n##    <chr>   <chr>  <chr>                                                                           <MULTIPOLYGON [°]>\n##  1 48      TX     Texas      (((-107 31.9, -107 32, -107 32, -107 32, -106 32, -106 32, -106 32, -106 32, -105 32...\n##  2 06      CA     California (((-119 33.5, -118 33.5, -118 33.4, -118 33.4, -118 33.3, -118 33.3, -118 33.3, -118...\n##  3 21      KY     Kentucky   (((-89.5 36.6, -89.5 36.6, -89.4 36.6, -89.4 36.6, -89.3 36.6, -89.3 36.6, -89.3 36....\n##  4 13      GA     Georgia    (((-85.6 35, -85.5 35, -85.4 35, -85.4 35, -85.3 35, -85.3 35, -85 35, -85 35, -85 3...\n##  5 55      WI     Wisconsin  (((-86.9 45.4, -86.8 45.5, -86.8 45.4, -86.9 45.4, -86.9 45.3, -87 45.4, -86.9 45.4)...\n##  6 41      OR     Oregon     (((-125 42.8, -124 43, -124 43, -124 43.1, -124 43.2, -124 43.2, -124 43.3, -124 43....\n##  7 29      MO     Missouri   (((-95.8 40.6, -95.5 40.6, -95.4 40.6, -95.3 40.6, -95.2 40.6, -95.1 40.6, -94.9 40....\n##  8 51      VA     Virginia   (((-76 37.3, -76 37.4, -76 37.4, -75.9 37.5, -75.9 37.6, -75.9 37.6, -75.9 37.7, -75...\n##  9 47      TN     Tennessee  (((-90.3 35, -90.3 35, -90.2 35.1, -90.2 35.1, -90.2 35.1, -90.1 35.1, -90.1 35.2, -...\n## 10 22      LA     Louisiana  (((-94 32.7, -94 32.8, -94 32.9, -94 33, -93.8 33, -93.8 33, -93.7 33, -93.5 33, -93...\n## # ℹ 42 more rows\n```\n:::\n\n\nIt looks like a regular R dataframe, and it is (all the regular dplyr functions work on it), but it has one added part—there's a special list column at the end named `geometry` that contains the actual geographic data, and the dataframe has special metadata with details about the map projection. As seen above, the data uses [NAD 83](https://geodesy.noaa.gov/datums/horizontal/north-american-datum-1983.shtml). We can change that to any projection we want, though, with `st_transform()`. To make life a little easier when calculating distances and combining maps later in this post, we'll convert this US map to the WGS 84 projection, which is what Google Maps (and all GPS systems) use:\n\n::: {.callout-tip}\n[See this for a short overview](https://datavizs22.classes.andrewheiss.com/example/12-example/#projections-and-coordinate-reference-systems) of projections and coordinate reference systems (CRS). You can [look up their ID numbers here](https://epsg.io/).\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nus_states <- us_states %>% \n  st_transform(st_crs(\"EPSG:4326\"))  # WGS 84\n\n# Just show some of the columns\nus_states %>% \n  select(STATEFP, STUSPS, NAME, geometry)\n## Simple feature collection with 52 features and 3 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -179 ymin: 17.9 xmax: 180 ymax: 71.4\n## Geodetic CRS:  WGS 84\n## # A tibble: 52 × 4\n##    STATEFP STUSPS NAME                                                                                      geometry\n##    <chr>   <chr>  <chr>                                                                           <MULTIPOLYGON [°]>\n##  1 48      TX     Texas      (((-107 31.9, -107 32, -107 32, -107 32, -106 32, -106 32, -106 32, -106 32, -105 32...\n##  2 06      CA     California (((-119 33.5, -118 33.5, -118 33.4, -118 33.4, -118 33.3, -118 33.3, -118 33.3, -118...\n##  3 21      KY     Kentucky   (((-89.5 36.6, -89.5 36.6, -89.4 36.6, -89.4 36.6, -89.3 36.6, -89.3 36.6, -89.3 36....\n##  4 13      GA     Georgia    (((-85.6 35, -85.5 35, -85.4 35, -85.4 35, -85.3 35, -85.3 35, -85 35, -85 35, -85 3...\n##  5 55      WI     Wisconsin  (((-86.9 45.4, -86.8 45.5, -86.8 45.4, -86.9 45.4, -86.9 45.3, -87 45.4, -86.9 45.4)...\n##  6 41      OR     Oregon     (((-125 42.8, -124 43, -124 43, -124 43.1, -124 43.2, -124 43.2, -124 43.3, -124 43....\n##  7 29      MO     Missouri   (((-95.8 40.6, -95.5 40.6, -95.4 40.6, -95.3 40.6, -95.2 40.6, -95.1 40.6, -94.9 40....\n##  8 51      VA     Virginia   (((-76 37.3, -76 37.4, -76 37.4, -75.9 37.5, -75.9 37.6, -75.9 37.6, -75.9 37.7, -75...\n##  9 47      TN     Tennessee  (((-90.3 35, -90.3 35, -90.2 35.1, -90.2 35.1, -90.2 35.1, -90.1 35.1, -90.1 35.2, -...\n## 10 22      LA     Louisiana  (((-94 32.7, -94 32.8, -94 32.9, -94 33, -93.8 33, -93.8 33, -93.7 33, -93.5 33, -93...\n## # ℹ 42 more rows\n```\n:::\n\n\nThe data's the same; the projection is different now. Neat.\n\nSince this is just a dataframe, we can manipulate it like any other dataframe. Let's filter it so that we only keep the 48 contiguous states:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlower_48 <- us_states %>% \n  filter(!(NAME %in% c(\"Alaska\", \"Hawaii\", \"Puerto Rico\")))\n```\n:::\n\n\n{sf} makes it incredibly easy to plot maps too. By relying on the geographic details embedded in the special `geometry` plot, the `geom_sf()` function automatically plots the correct kind of data (points, lines, or areas). And since we're just working with a dataframe, everything in the grammar of graphics paradigm works too. We can map columns to specific aesthetics. For instance, the Census shapefile happened to come with a column named `ALAND` that measures the total land area in each state in square meters. We can fill by that column and create a choropleth map showing states by size:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = lower_48, aes(fill = ALAND))\n```\n\n::: {.cell-output-display}\n![Basic map of the US, with states filled by area](index_files/figure-html/us-map-basic-1.png){fig-align='center' fig-alt='Basic map of the US, with states filled by area' width=90%}\n:::\n:::\n\n\nSince this is just a regular ggplot geom, all other ggplot things work, like modifying themes, scales, etc. We can also change the projection on-the-fly with `coord_sf()` (here I use [Albers](https://epsg.io/102003)):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(scales)\n\nggplot() +\n  geom_sf(data = lower_48, aes(fill = ALAND),\n          color = \"white\", linewidth = 0.1) +\n  scale_fill_viridis_c(option = \"rocket\", end = 0.9,\n                       labels = label_number(scale_cut = cut_short_scale()),\n                       guide = guide_colorbar(barwidth = 7, barheight = 0.4,\n                                              title.vjust = 1)) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers projection\n  labs(fill = \"Land area (m²)\") +\n  theme_void(base_family = \"Overpass Light\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_text(face = \"bold\"),\n        legend.text = element_text(size = rel(0.6)),\n        legend.justification = \"center\")\n```\n\n::: {.cell-output-display}\n![Fancier map of the US, with states filled by area](index_files/figure-html/us-map-fancy-1.png){fig-align='center' fig-alt='Fancier map of the US, with states filled by area' width=90%}\n:::\n:::\n\n\n\n## Getting geographic data\n\nShapefiles are everywhere. They're one of the de facto standard formats for GIS data, and most government agencies provide them for their jurisdictions ([see here for a list of some different sources](https://datavizs22.classes.andrewheiss.com/example/12-example/#shapefiles)). You can view and edit them graphically with the free and open source [QGIS](https://qgis.org/en/site/) or with the expensive and industry-standard [ArcGIS](https://www.arcgis.com/index.html).\n\nWe've already seen how to load shapefiles into R with `sf::read_sf()`, and that works great. But doing that requires that you go and find and download the shapefiles that you want, which can involve hunting through complicated websites. There are also lots of different R packages that let you get shapefiles directly from different websites' APIs.\n\nFor example, we've already loaded the 2022 US Census maps by downloading and unzipping the shapefile and using `read_sf()`. We could have also used the [{tigris}](https://github.com/walkerke/tigris) package to access the data directly from the Census, like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tigris)\n\nus_states <- states(resolution = \"20m\", year = 2022, cb = TRUE)\n\nlower_48 <- us_states %>% \n  filter(!(NAME %in% c(\"Alaska\", \"Hawaii\", \"Puerto Rico\")))\n```\n:::\n\n\nFor world-level data, [Natural Earth](https://www.naturalearthdata.com/) has incredibly well-made shapefiles. We could download the [1:50m cultural data](https://www.naturalearthdata.com/downloads/50m-cultural-vectors/) from their website, unzip it, and load it with `read_sf()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Medium scale data, 1:50m Admin 0 - Countries\n# Download from https://www.naturalearthdata.com/downloads/50m-cultural-vectors/\nworld_map <- read_sf(\"ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp\") %>% \n  filter(iso_a3 != \"ATA\")  # Remove Antarctica\n```\n:::\n\n\nOr we can use the [{rnaturalearth}](https://github.com/ropensci/rnaturalearth) package to do the same thing:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(rnaturalearth)\n\n# rerturnclass = \"sf\" makes it so the resulting dataframe has the special\n# sf-enabled geometry column\nworld_map <- ne_countries(scale = 50, returnclass = \"sf\") %>% \n  filter(iso_a3 != \"ATA\")  # Remove Antarctica\n```\n:::\n\n\n::: {.callout-important}\nThroughout this post, I use {rnaturalearth} for world-level shapefiles and downloaded shapefiles for the US, but that's just for the sake of illustration. Both can be done with packages or through downloading.\n:::\n\nAnd finally, for fun, here are some examples of different maps and projections and ggplot tinkering. I'm perpetually astounded by how easy it is to plot GIS data with `geom_sf()`! That `geometry` list column is truly magical.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\np1 <- ggplot() + \n  geom_sf(data = lower_48, fill = \"#0074D9\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"EPSG:4269\")) +  # NAD83\n  labs(title = \"NAD83 projection\") +\n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5, family = \"Overpass Light\"))\n\np2 <- ggplot() + \n  geom_sf(data = lower_48, fill = \"#0074D9\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  labs(title = \"Albers projection\") +\n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5, family = \"Overpass Light\"))\n\np3 <- ggplot() +\n  geom_sf(data = world_map, fill = \"#FF4136\", color = \"white\", linewidth = 0.1) +\n  coord_sf(crs = st_crs(\"EPSG:3395\")) +  # Mercator\n  labs(title = \"Mercator projection\") +\n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5, family = \"Overpass Light\"))\n\np4 <- ggplot() +\n  geom_sf(data = world_map, fill = \"#FF4136\", color = \"white\", linewidth = 0.1) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  labs(title = \"Robinson projection\") +\n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5, family = \"Overpass Light\"))\n\n(p1 | p2) / (p3 | p4)\n```\n\n::: {.cell-output-display}\n![Examples of different North American and world map projections](index_files/figure-html/example-projections-1.png){fig-align='center' fig-alt='Examples of different North American and world map projections' width=90%}\n:::\n:::\n\n\n\n# Quick reminder: latitude vs. longitude\n\nOne last little GIS-related thing before going to Middle Earth. Geographic data doesn't rely on the standard X/Y Cartesian plane. Instead, it uses latitudes and longitudes. I've loved maps and globes all my life, but I *can never remember* how latitudes and longitudes translate to X and Y, especially since coordinates are often reported as `lat, lon`, which is technically the reverse of `x, y`. \n\nI have this graph printed and hanging on my office wall next to my computer and refer to it all the time. It's my gift to all of you.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\npoint_example <- tibble(x = 2, y = 1) %>%\n  mutate(label = glue::glue(\"{x} x, {y} y\\n{y} lat, {x} lon\"))\nlat_labs <- tibble(x = -3, y = seq(-2, 3, 1), label = \"Latitude\")\nlon_labs <- tibble(x = seq(-2, 3, 1), y = -2, label = \"Longitude\")\n\nggplot() +\n  geom_point(data = point_example, aes(x = x, y = y), size = 5) +\n  geom_label(data = point_example, aes(x = x, y = y, label = label),\n             nudge_y = 0.6, family = \"Overpass ExtraBold\") +\n  geom_text(data = lat_labs, aes(x = x, y = y, label = label),\n            hjust = 0.5, vjust = -0.3, family = \"Overpass Light\") +\n  geom_text(data = lon_labs, aes(x = x, y = y, label = label),\n            hjust = 1.1, vjust = -0.5, angle = 90, family = \"Overpass Light\") +\n  geom_hline(yintercept = 0) +\n  geom_vline(xintercept = 0) +\n  scale_x_continuous(breaks = seq(-2, 3, 1)) +\n  scale_y_continuous(breaks = seq(-2, 3, 1)) +\n  coord_equal(xlim = c(-3.5, 3), ylim = c(-3, 3)) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal() +\n  theme(panel.grid.minor = element_blank(),\n        axis.text = element_blank())\n```\n\n::: {.cell-output-display}\n![Helpful diagram showing how latitude and longitude translate to x and y coordinates](index_files/figure-html/lat-lon-plot-1.png){fig-align='center' fig-alt='Helpful diagram showing how latitude and longitude translate to x and y coordinates' width=65%}\n:::\n:::\n\n\n\n# Loading Middle Earth shapefiles\n\nPhew, okay. With that quick overview done, we can start playing with the [ME-GIS data](https://github.com/jvangeld/ME-GIS). There's isn't a pre-built R package for the data, so we'll need to download the GitHub repository ourselves. I put all the files in a folder named `data/ME-GIS` relative to this document. I also downloaded the [2022 US Census cartographic boundary files](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html) and put them in a folder named `data/cb_2022_us_state_20m`. If you're following along, I suggest you do the same. \n\nThe ME-GIS project includes tons of different shapefile layers: data for coastline borders, elevation contours, forest boundaries, city locations, and so on. We'll load a bunch of them here. \n\nNotice the extra `iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")` that I've added to each `read_sf()` call. This is necessary because the original data isn't stored as Unicode, which is an issue because Tolkien used all sorts of accents (like \"Lórien\"), and R can choke on these characters. To make life easier, I use `iconv()` to convert all the character columns in each shapefile from [Latin 1 (ISO-8859-1)](https://en.wikipedia.org/wiki/ISO/IEC_8859-1) to Unicode (UTF-8).\n\nMake sure you download and install the [Overpass font from Google Fonts](https://fonts.google.com/specimen/Overpass) if you want to use the custom fonts throughout the post.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(rnaturalearth)\nlibrary(ggspatial)\nlibrary(scales)\nlibrary(patchwork)\nlibrary(leaflet)\nlibrary(glue)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoastline <- read_sf(\"data/ME-GIS/Coastline2.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\ncontours <- read_sf(\"data/ME-GIS/Contours_18.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nrivers <- read_sf(\"data/ME-GIS/Rivers.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nroads <- read_sf(\"data/ME-GIS/Roads.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nlakes <- read_sf(\"data/ME-GIS/Lakes.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nregions <- read_sf(\"data/ME-GIS/Regions_Anno.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nforests <- read_sf(\"data/ME-GIS/Forests.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nmountains <- read_sf(\"data/ME-GIS/Mountains_Anno.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\nplacenames <- read_sf(\"data/ME-GIS/Combined_Placenames.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n```\n:::\n\n\nWe'll also load and process the Census data and Natural Earth data (we did this before in the overivew, but we'll do it again here in case you skipped that part):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Census data\nus_states <- read_sf(\"data/cb_2022_us_state_20m/cb_2022_us_state_20m.shp\") %>% \n  st_transform(st_crs(\"EPSG:4326\"))\n\nlower_48 <- us_states %>% \n  filter(!(NAME %in% c(\"Alaska\", \"Hawaii\", \"Puerto Rico\")))\n\n# Natural Earth data\nworld_map <- ne_countries(scale = 50, returnclass = \"sf\") %>% \n  filter(iso_a3 != \"ATA\")  # Remove Antarctica\n```\n:::\n\n\nFinally, we'll define a couple little helper functions to convert between meters and miles (the Middle Earth data is stored as meters), and define some colors that we'll use in the maps.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmiles_to_meters <- function(x) {\n  x * 1609.344\n}\n\nmeters_to_miles <- function(x) {\n  x / 1609.344\n}\n\nclr_green <- \"#035711\"\nclr_blue <- \"#0776e0\"\nclr_yellow <- \"#fffce3\"\n\n# Format numeric coordinates with degree symbols and cardinal directions\nformat_coords <- function(coords) {\n  ns <- ifelse(coords[[1]][2] > 0, \"N\", \"S\")\n  ew <- ifelse(coords[[1]][1] > 0, \"E\", \"W\")\n  \n  glue(\"{latitude}°{ns} {longitude}°{ew}\",\n       latitude = sprintf(\"%.6f\", coords[[1]][2]),\n       longitude = sprintf(\"%.6f\", coords[[1]][1]))\n}\n```\n:::\n\n\n\n\n# Exploring the different layers\n\nWith all these shapefiles loaded, we can experiment with them and see what's in them. Here's the coastline:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = coastline, linewidth = 0.25, color = \"grey50\") \n```\n\n::: {.cell-output-display}\n![Middle Earth's coastline](index_files/figure-html/basic-coastline-1.png){fig-align='center' fig-alt='Middle Earth\\'s coastline' width=70%}\n:::\n:::\n\n\nNeat. We can add some rivers and lakes to it:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = coastline, linewidth = 0.25, color = \"grey50\") +\n  geom_sf(data = rivers, linewidth = 0.2, color = clr_blue, alpha = 0.5) +\n  geom_sf(data = lakes, linewidth = 0.2, color = clr_blue, fill = clr_blue)\n```\n\n::: {.cell-output-display}\n![Middle Earth with rivers and lakes](index_files/figure-html/basic-coastline-rivers-1.png){fig-align='center' fig-alt='Middle Earth with rivers and lakes' width=70%}\n:::\n:::\n\n\nThe level of detail in these coastlines and borders is *incredible*. Great work, ME-DEM team!\n\nLet's add placenames:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = coastline, linewidth = 0.25, color = \"grey50\") +\n  geom_sf(data = rivers, linewidth = 0.2, color = clr_blue, alpha = 0.5) +\n  geom_sf(data = lakes, linewidth = 0.2, color = clr_blue, fill = clr_blue) +\n  geom_sf(data = placenames, size = 0.5)\n```\n\n::: {.cell-output-display}\n![Middle Earth with rivers and lakes and too many places](index_files/figure-html/basic-coastline-rivers-places-1.png){fig-align='center' fig-alt='Middle Earth with rivers and lakes and too many places' width=70%}\n:::\n:::\n\n\nHa, that's less than helpful. There are 785 different placenames in the data. Since the `placenames` object is just a fancy dataframe, we can filter it and just look at a few of the places: Hobbiton (the Shire), Rivendell, Edoras (capital of Rohan), and Minas Tirith (capital of Gondor). We'll also add labels with `geom_sf_label()` and scoot the labels up a bit so that they're not on top of the points. The geographic data here is measured in meters, so we can specify how many meters we want each label moved up. Because I don't think in the metric system, and because there are 1,609 meters in a mile and that implies big numbers, I'll specify the label offset in miles with the `miles_to_meters()` function we made earlier. We'll push the labels up by 50 miles (or 80,467 meters):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplaces <- placenames %>% \n  filter(NAME %in% c(\"Hobbiton\", \"Rivendell\", \"Edoras\", \"Minas Tirith\"))\n\nggplot() +\n  geom_sf(data = coastline, linewidth = 0.25, color = \"grey50\") +\n  geom_sf(data = rivers, linewidth = 0.2, color = clr_blue, alpha = 0.5) +\n  geom_sf(data = lakes, linewidth = 0.2, color = clr_blue, fill = clr_blue) +\n  geom_sf(data = places, size = 1) +\n  geom_sf_label(data = places, aes(label = NAME), nudge_y = miles_to_meters(50))\n```\n\n::: {.cell-output-display}\n![Middle Earth with rivers, lakes, and four cities](index_files/figure-html/basic-coastline-rivers-places-small-1.png){fig-align='center' fig-alt='Middle Earth with rivers, lakes, and four cities' width=70%}\n:::\n:::\n\n\n# Fancy map of Middle Earth with lots of layers\n\nSo far we've seen that we can stack up as many `geom_sf()` layers as we want to combine each of these shapefiles into a single plot, and we can modify each of the layers just like a standard ggplot geom. Here's a more polished fancy final version of Middle Earth with better colors, fonts, elevation contours, and so on.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplaces <- placenames %>% \n  filter(NAME %in% c(\"Hobbiton\", \"Rivendell\", \"Edoras\", \"Minas Tirith\"))\n\nggplot() +\n  geom_sf(data = contours, linewidth = 0.15, color = \"grey90\") +\n  geom_sf(data = coastline, linewidth = 0.25, color = \"grey50\") +\n  geom_sf(data = rivers, linewidth = 0.2, color = clr_blue, alpha = 0.5) +\n  geom_sf(data = lakes, linewidth = 0.2, color = clr_blue, fill = clr_blue) +\n  geom_sf(data = forests, linewidth = 0, fill = clr_green, alpha = 0.5) +\n  geom_sf(data = mountains, linewidth = 0.25, linetype = \"dashed\") +\n  geom_sf(data = places) +\n  geom_sf_label(data = places, aes(label = NAME), nudge_y = miles_to_meters(40),\n                family = \"Overpass ExtraBold\", fontface = \"plain\") +\n  theme_void() +\n  theme(plot.background = element_rect(fill = clr_yellow))\n```\n\n::: {.cell-output-display}\n![Complete fancy map of Middle Earth](index_files/figure-html/full-nice-map-1.png){fig-align='center' fig-alt='Complete fancy map of Middle Earth' width=100%}\n:::\n:::\n\n\n\n# Map of just the Shire\n\nThat's a really neat map! We can get even fancier though! Given the quality of the geographic data, we can zoom in and get much more detail for specific regions. For instance, we can zoom in on just the Shire. We can specify a window of coordinates in `coord_sf()` to zoom the plot, and with actual real world data we could [use a tool like this](https://www.openstreetmap.org/export#map=4/54.47/12.79) to find those coordinates on a map, but since this is fictional data, it's a little bit trickier to define specific bounds. \n\nTo find the rough bounds of the Shire, we'll first extract the coordinates for Hobbiton, home of Bilbo and Frodo Baggins. The geographic data is currently stuck in the `geometry` list column, but we can use `map_dbl()` from {purrr} to extract the values as numbers:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhobbiton <- places %>% \n  filter(NAME == \"Hobbiton\") %>% \n  mutate(geometry_x = map_dbl(geometry, ~as.numeric(.)[1]),\n         geometry_y = map_dbl(geometry, ~as.numeric(.)[2]))\n\nhobbiton %>% \n  select(LAYER, NAME, geometry_x, geometry_y)\n## Simple feature collection with 1 feature and 4 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 516000 ymin: 1040000 xmax: 516000 ymax: 1040000\n## Projected CRS: UTM_Zone_31_Northern_Hemisphere\n## # A tibble: 1 × 5\n##   LAYER     NAME     geometry_x geometry_y         geometry\n##   <chr>     <chr>         <dbl>      <dbl>      <POINT [m]>\n## 1 TownNames Hobbiton    515948.   1043820. (515948 1043820)\n```\n:::\n\n\nAlternatively, we can avoid {purrr} stuff and pull out the numbers directly with `st_geometry()`. I prefer keeping everything inside the dataframe, though, so I typically use {purrr} for this kind of thing.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhobbiton_no_df <- places %>% \n  filter(NAME == \"Hobbiton\") %>% \n  st_geometry()\nhobbiton_no_df\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 516000 ymin: 1040000 xmax: 516000 ymax: 1040000\n## Projected CRS: UTM_Zone_31_Northern_Hemisphere\n## POINT (515948 1043820)\nhobbiton_no_df[[1]][1]\n## [1] 515948\nhobbiton_no_df[[1]][2]\n## [1] 1043820\n```\n:::\n\n\nThose (515948, 1043820) coordinates are the location of Hobbiton and they're measured in meters. We can add and subtract some amount of meters to each side of the coordinates to build a window around Hobbiton and set the bounds of the map. Here I add 30 miles to the west, 60 miles to the east, 35 miles to the north, and 20 miles to the south of Hobbiton (I figured those out through a bunch of trial and error to get the main features and labels that I wanted to show in the fancier map below)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshire_towns <- placenames %>% filter(LAYER == \"TownNames\")\n\nggplot() +\n  geom_sf(data = rivers, linewidth = 0.45, color = clr_blue, alpha = 0.5) +\n  geom_sf(data = roads) +\n  geom_sf(data = shire_towns, size = 2) +\n  geom_sf_label(data = shire_towns, aes(label = NAME), nudge_y = miles_to_meters(3),\n                family = \"Overpass ExtraBold\", fontface = \"plain\") +\n  coord_sf(xlim = c(hobbiton$geometry_x - miles_to_meters(30), \n                    hobbiton$geometry_x + miles_to_meters(60)),\n           ylim = c(hobbiton$geometry_y - miles_to_meters(35), \n                    hobbiton$geometry_y + miles_to_meters(20)))\n```\n\n::: {.cell-output-display}\n![Basic zoomed-in map of the Shire](index_files/figure-html/shire-zoomed-in-basic-1.png){fig-align='center' fig-alt='Basic zoomed-in map of the Shire' width=100%}\n:::\n:::\n\n\nUsing that window of coordinates, we can make the map extra fancy with some more enhancements. The roads data, for instance, includes a column that indicates if a road is primary, secondary, or tertiary, so we can size by road importance. We can also add some neat little annotations, like a compass indicator and a scale marker (using `annotation_scale()` and `annotation_north_arrow()` from the [{ggspatial} package](https://paleolimbot.github.io/ggspatial/)). We'll also add a Tolkienesque plot title with [the Aniron font](https://www.dafont.com/aniron.font):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshire_towns <- placenames %>% filter(LAYER == \"TownNames\")\n\nggplot() +\n  geom_sf(data = roads, aes(linewidth = TYPE), color = \"grey80\") +\n  geom_sf(data = coastline, linewidth = 0.25, color = \"grey50\") +\n  geom_sf(data = rivers, linewidth = 0.45, color = clr_blue, alpha = 0.5) +\n  geom_sf_text(data = rivers, aes(label = NAME), color = clr_blue,\n               family = \"Overpass SemiBold\", fontface = \"italic\", size = 3.5) +\n  geom_sf_text(data = regions, aes(label = name),\n               family = \"Overpass Heavy\", size = 5, color = \"grey30\") +\n  geom_sf(data = forests, linewidth = 0, fill = clr_green, alpha = 0.4) +\n  geom_sf_text(data = forests, aes(label = NAME), nudge_y = miles_to_meters(1),\n               color = clr_green, family = \"Overpass ExtraBold\", fontface = \"italic\", size = 4) +\n  geom_sf(data = shire_towns, size = 2) +\n  geom_sf_label(data = shire_towns, aes(label = NAME), nudge_y = miles_to_meters(3),\n                family = \"Overpass ExtraBold\", fontface = \"plain\") +\n  scale_linewidth_discrete(range = c(1, 0.3), guide = \"none\") +\n  annotation_scale(location = \"tl\", bar_cols = c(\"grey30\", \"white\"),\n                   text_family = \"Overpass\",\n                   unit_category = \"imperial\") +\n  annotation_north_arrow(\n    location = \"tl\", pad_y = unit(1.5, \"lines\"),\n    style = north_arrow_fancy_orienteering(fill = c(\"grey30\", \"white\"), \n                                           line_col = \"grey30\",\n                                           text_family = \"Overpass\")) +\n  coord_sf(xlim = c(hobbiton$geometry_x - miles_to_meters(30), \n                    hobbiton$geometry_x + miles_to_meters(60)),\n           ylim = c(hobbiton$geometry_y - miles_to_meters(35), \n                    hobbiton$geometry_y + miles_to_meters(20))) +\n  labs(title = \"The Shire\") +\n  theme_void() +\n  theme(plot.background = element_rect(fill = clr_yellow),\n        plot.title = element_text(family = \"Aniron\", size = rel(2), \n                                  hjust = 0.02))\n```\n\n::: {.cell-output-display}\n![Fancy zoomed-in map of the Shire](index_files/figure-html/shire-zoomed-in-fancy-1.png){fig-align='center' fig-alt='Fancy zoomed-in map of the Shire' width=100%}\n:::\n:::\n\n\nahhh that's so cool!\n\n\n# Distances between places\n\nWe're not done yet though! We can do a lot more GIS-related work with R. Let's calculate some distances for fun!\n\nIn the first half of *The Fellowship of the Ring*, Frodo, Sam, Merry, and Pippin travel from the Shire to Rivendell. How long of a journey was that?\n\nTo figure this out we can extract the coordinates for Rivendell and then find the difference between it and Hobbiton. This doesn't follow any roads or anything—it's just as the Nazgûl flies—but it should be fairly accurate.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Find coordinates for Rivendell\nrivendell <- places %>% filter(NAME == \"Rivendell\")\n\nst_distance(hobbiton, rivendell) %>% meters_to_miles()\n## Units: [m]\n##      [,1]\n## [1,]  229\n```\n:::\n\n\nAccording to Karen Wynn Fonstad's [*Atlas of Middle-earth*](https://www.amazon.com/Atlas-Middle-Earth-Revised-Karen-Fonstad/dp/0618126996), though, this should be [458 miles](https://www.councilofelrond.com/craft/follow-the-fellowship-walk-to-rivendell-and-beyond/), which is exactly double the amount we just found! Somehow the distances between everything in the shapefiles are halved from regular-Earth miles. \n\nTo fix this we can double the distance between Hobbiton and everything else in the dataset, expanding the data from Hobbiton, which now acts like the center of the world\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nme_scaled <- places %>%\n  filter(NAME %in% c(\"Hobbiton\", \"Rivendell\", \"Edoras\", \"Minas Tirith\")) %>% \n  # Take the existing coordinates, subtract the doubled Hobbiton coordinates,\n  # and add the Hobbiton coordinates\n  st_set_geometry((st_geometry(.) - st_geometry(hobbiton)) * 2 + st_geometry(hobbiton))\n\n# Extract new coordinates from scaled-up version\nhobbiton_scaled <- me_scaled %>% filter(NAME == \"Hobbiton\")\nrivendell_scaled <- me_scaled %>% filter(NAME == \"Rivendell\")\n\n# Fixed!\nst_distance(hobbiton_scaled, rivendell_scaled) %>% meters_to_miles()\n##      [,1]\n## [1,]  458\n```\n:::\n\n\nThat's correct now—it was 458 miles from the Shire to Rivendell.\n\n\n# Sticking Middle Earth in Real Earth\n\nNow that we can work with correct distances, we can sick Middle Earth inside Real Earth to help visualize how far spread out Tolkien's world is. \n\n## In the United States\n\nFirst, let's stick a scaled-up version of Middle Earth in the United States. For fun, we'll put the Shire in the geographic center of the US, and we'll calculate the coordinates for that with R just to show that it's possible.\n\nCurrently we have a dataset with 49 rows (48 states + DC). We can use the `st_centroid()` function to find the center of geographic areas, but if we use it on our current data, we'll get 49 separate centers. So instead, we'll melt all the states into one big geographic shape with `group_by()` and `summarize()` (using `summarize()` on the `geometry` column in an `sf` dataset combines the geographic areas), and then use `st_centroid()` on that: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Melt the lower 48 states into one big shape first, then use st_centroid()\nus_dissolved <- lower_48 %>% \n  mutate(country = \"US\") %>%  # Create new column with the country name \n  group_by(country) %>%  # Group by that country name column\n  summarize()  # Collapse all the geographic data into one big blob\nus_dissolved\n## Simple feature collection with 1 feature and 1 field\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -125 ymin: 24.5 xmax: -66.9 ymax: 49.4\n## Geodetic CRS:  WGS 84\n## # A tibble: 1 × 2\n##   country                                                                                geometry\n##   <chr>                                                                        <MULTIPOLYGON [°]>\n## 1 US      (((-68.9 43.8, -68.9 43.8, -68.8 43.8, -68.9 43.9, -68.9 43.9, -68.9 43.8)), ((-71.6...\n\nus_center <- us_dissolved %>% \n  st_geometry() %>%  # Extract the geometry column\n  st_centroid()  # Find the center\nus_center\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -99 ymin: 39.8 xmax: -99 ymax: 39.8\n## Geodetic CRS:  WGS 84\n## POINT (-99 39.8)\n```\n:::\n\n\nAccording to these calculations, the center of the contiguous US is 39.751441°N -98.965620°W. Technically that's not 100% correct—[the true location](https://en.wikipedia.org/wiki/Geographic_center_of_the_United_States#Contiguous_United_States) is at 39.833333°N -98.583333°W, but this is close enough ([according to Google, it's 25 miles off](https://www.google.com/maps/dir/39.751441,+-98.965620/39.833333,-98.583333/@39.8236494,-98.9352692,11z/)). I'm guessing the discrepancy is due to differences in the shapefile—I'm not using the highest resolution possible, and there might be islands I need to account for (or not account for). Who knows.\n\nHere's where that is. I'm using the [{leaflet} package](https://rstudio.github.io/leaflet/) just for fun here (this post is a showcase of different R-based GIS things, so let's showcase!):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nus_center_plot <- us_dissolved %>% \n  st_centroid() %>% \n  mutate(fancy_coords = format_coords(geometry)) %>% \n  mutate(label = glue(\"<span style='display: block; text-align: center;'><strong>Roughly of the center of the contiguous US</strong>\",\n                      \"<br>{fancy_coords}</span>\"))\n\nleaflet(us_center_plot) %>% \n  setView(lng = st_geometry(us_center_plot)[[1]][1], \n          lat = st_geometry(us_center_plot)[[1]][2], \n          zoom = 4) %>%\n  addTiles() %>% \n  addCircleMarkers(label = ~htmltools::HTML(label),\n                   labelOptions = labelOptions(noHide = TRUE, \n                                               direction = \"top\", \n                                               textOnly = FALSE))\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"leaflet html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-cd58c04d1217b7d569e4\" style=\"width:100%;height:355.995055624227px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-cd58c04d1217b7d569e4\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"setView\":[[39.7514407352008,-98.9656202327183],4,[]],\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"https://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]},{\"method\":\"addCircleMarkers\",\"args\":[39.7514407352008,-98.9656202327183,10,null,null,{\"interactive\":true,\"className\":\"\",\"stroke\":true,\"color\":\"#03F\",\"weight\":5,\"opacity\":0.5,\"fill\":true,\"fillColor\":\"#03F\",\"fillOpacity\":0.2},null,null,null,null,\"<span style='display: block; text-align: center;'><strong>Roughly of the center of the contiguous US<\\/strong><br>39.751441°N -98.965620°W<\\/span>\",{\"interactive\":false,\"permanent\":true,\"direction\":\"top\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[39.7514407352008,39.7514407352008],\"lng\":[-98.9656202327183,-98.9656202327183]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\nNext, we need to transform the Middle Earth data so that it fits on the US map. We need to do a few things to make this work:\n\n1. Double all the distances so they match Real World miles\n2. Change the projection of each of the Middle Earth-related datasets to match the projection of `lower_48`, or [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System), or [EPSG:4326](https://epsg.io/4326)\n3. Shift the Middle Earth-related datasets so that Hobbiton aligns with the center of the US.\n\nChanging the projection of an {sf}-enabled dataset is super easy with `st_transform()`. Let's first transform the CRS for the Hobbiton coordinates:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhobbiton_in_us <- hobbiton %>% \n  st_transform(st_crs(lower_48))\n\nhobbiton_in_us %>% st_geometry()\n## Geometry set for 1 feature \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 3.15 ymin: 9.44 xmax: 3.15 ymax: 9.44\n## Geodetic CRS:  WGS 84\n## POINT (3.15 9.44)\n```\n:::\n\n\nNote how the coordinates are now on the [decimal degrees scale](https://en.wikipedia.org/wiki/Decimal_degrees) (3.15, 9.44) instead of the meter scale (515948, 1043820). That's how the US map is set up, so now we can do GIS math with the two maps.\n\nNext, we need to calculate the offset from the center of the US and Hobbiton by finding the difference between the two sets of coordinates:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nme_to_us <- st_coordinates(us_center) - st_coordinates(hobbiton_in_us)\nme_to_us\n##         X    Y\n## [1,] -102 30.3\n```\n:::\n\n\nNow we can use that offset to redefine the geometry column in any Middle Earth-related {sf}-enabled dataset we have. Here's the process for the `places` data—it'll be the same for any of the other shapefiles.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nme_places_in_us <- places %>% \n  # Make the Middle Earth data match the US projection\n  st_transform(st_crs(lower_48)) %>%\n  # Just look at a handful of places\n  filter(NAME %in% c(\"Hobbiton\", \"Rivendell\", \"Edoras\", \"Minas Tirith\")) %>% \n  # Double the distances\n  st_set_geometry((st_geometry(.) - st_geometry(hobbiton_in_us)) * 2 + st_geometry(hobbiton_in_us)) %>% \n  # Shift everything around so that Hobbiton is in the center of the US\n  st_set_geometry(st_geometry(.) + me_to_us) %>% \n  # All the geometry math made us lose the projection metadata; set it again\n  st_set_crs(st_crs(lower_48))\n```\n:::\n\n\nWe can now stick this US-transformed set of place locations insde a map of the US. (Note the ±70000 values for nudging. I have no idea what scale these are on—they're not meters or miles (maybe feet? maybe decimal degrees?). I had to tinker with different values until it looked okay.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = lower_48, fill = \"#FF851B\", color = \"white\", linewidth = 0.25) +\n  geom_sf(data = me_places_in_us) +\n  geom_sf_label(data = filter(me_places_in_us, NAME %in% c(\"Hobbiton\", \"Edoras\")),\n                aes(label = NAME), nudge_x = -70000, hjust = 1) +\n  geom_sf_label(data = filter(me_places_in_us, NAME %in% c(\"Rivendell\", \"Minas Tirith\")),\n                aes(label = NAME), nudge_x = 70000, hjust = 0) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n::: {.cell-output-display}\n![Middle Earth locations placed in the US](index_files/figure-html/basic-us-me-places-1.png){fig-align='center' fig-alt='Middle Earth locations placed in the US' width=100%}\n:::\n:::\n\n\nAssuming the Shire is in the middle of Kansas, Rivendell would be near the Mississippi River in Missouri. Rohan is down in southern Arkansas, while Gondor is in southern Alabama. \n\nWe could be even fancier and reshift *all* the Middle Earth shapefiles to fit in the US, and then overlay all of Middle Earth on the US, but I won't do that here. I'll just stick the coastline on so we can compare the relative sizes of the US and Middle Earth:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoastline_in_us <- coastline %>% \n  st_transform(st_crs(lower_48)) %>%\n  st_set_geometry((st_geometry(.) - st_geometry(hobbiton_in_us)) * 2 + st_geometry(hobbiton_in_us)) %>% \n  st_set_geometry(st_geometry(.) + me_to_us) %>% \n  st_set_crs(st_crs(lower_48))\n\nggplot() + \n  geom_sf(data = lower_48, fill = \"#FF851B\", color = \"white\", linewidth = 0.25) +\n  geom_sf(data = coastline_in_us, linewidth = 0.25) +\n  geom_sf(data = me_places_in_us) +\n  geom_sf_label(data = filter(me_places_in_us, NAME %in% c(\"Hobbiton\", \"Edoras\")),\n                aes(label = NAME), nudge_x = -70000, hjust = 1) +\n  geom_sf_label(data = filter(me_places_in_us, NAME %in% c(\"Rivendell\", \"Minas Tirith\")),\n                aes(label = NAME), nudge_x = 70000, hjust = 0) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n::: {.cell-output-display}\n![Middle Earth locations and borders placed in the US](index_files/figure-html/fancier-us-me-places-1.png){fig-align='center' fig-alt='Middle Earth locations and borders placed in the US' width=100%}\n:::\n:::\n\n\n## In Europe\n\nSticking Middle Earth in the US makes sense because I live in the US, so these relative distances are straightforward to me. (I'm in Georgia, which is the middle of Mordor in the maps above).\n\nBut Tolkien was from England and lived in Oxford—at [20 Northmoor Road](https://en.wikipedia.org/wiki/Northmoor_Road) to be precise, or at [51.771004°N -1.260142°W](https://www.google.com/maps/place/20+Northmoor+Rd,+Oxford+OX2+6UR,+UK/@51.7710103,-1.2626846,17z/) to be even more precise (I found this by going to Google Maps, right clicking on Tolkien's home, and copying the coordinates). Here's where that is:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntolkien_home <- tribble(\n  ~place, ~lat, ~long,\n  \"Tolkien's home\", 51.771003605142724, -1.2601418874304429\n) %>% \n  st_as_sf(coords = c(\"long\", \"lat\"), crs = st_crs(\"EPSG:4326\")) \n\ntolkien_home_plot <- tolkien_home %>% \n  mutate(fancy_coords = format_coords(geometry)) %>% \n  mutate(label = glue(\"<span style='display: block; text-align: center;'><strong>{place}</strong>\",\n                      \"<br>{fancy_coords}</span>\"))\n\nleaflet(tolkien_home_plot) %>% \n  setView(lng = st_geometry(tolkien_home_plot)[[1]][1], \n          lat = st_geometry(tolkien_home_plot)[[1]][2], \n          zoom = 14) %>%\n  addTiles() %>% \n  addCircleMarkers(label = ~htmltools::HTML(label),\n                   labelOptions = labelOptions(noHide = TRUE, \n                                               direction = \"top\", \n                                               textOnly = FALSE))\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"leaflet html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-b025034012f814278eae\" style=\"width:100%;height:355.995055624227px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-b025034012f814278eae\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"setView\":[[51.7710036051427,-1.26014188743044],14,[]],\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"https://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]},{\"method\":\"addCircleMarkers\",\"args\":[51.7710036051427,-1.26014188743044,10,null,null,{\"interactive\":true,\"className\":\"\",\"stroke\":true,\"color\":\"#03F\",\"weight\":5,\"opacity\":0.5,\"fill\":true,\"fillColor\":\"#03F\",\"fillOpacity\":0.2},null,null,null,null,\"<span style='display: block; text-align: center;'><strong>Tolkien's home<\\/strong><br>51.771004°N -1.260142°W<\\/span>\",{\"interactive\":false,\"permanent\":true,\"direction\":\"top\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[51.7710036051427,51.7710036051427],\"lng\":[-1.26014188743044,-1.26014188743044]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\nWe can put Hobbiton in Tolkien's home and then see the relative distances to the rest of Middle Earth from Oxford.\n\nWe'll use the Natural Earth data that we loaded at the beginning of this post. We could theoretically filter it to only look at European countries, since it includes a column for continent, but doing so causes all sorts of issues:\n\n- Russia is huuuuge\n- French Guiana is officially part of France, so the map includes a part of South America\n- Other countries like Denmark, Norway, and the UK have similar overseas province-like territories, so the map gets even more expanded\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\neurope <- world_map %>% \n  filter(continent == \"Europe\")\n\nggplot() +\n  geom_sf(data = europe)\n```\n\n::: {.cell-output-display}\n![Ugly map of all European countries](index_files/figure-html/europe-only-not-great-1.png){fig-align='center' fig-alt='Ugly map of all European countries' width=100%}\n:::\n:::\n\n\nWe could do some fancy filtering and [use more detailed data that splits places like France into separate subdivisions](https://github.com/nvkelso/natural-earth-vector/issues/196) (i.e. one row for continental Europe France, one row for French Guiana, etc.), but that's a lot of work. So instead, we'll use `coord_sf()` to define a window so we can zoom in on just a chunk of Europe. Before, we added some arbitrary number of miles around the coordinates for Hobbiton. This time we'll [use a helpful tool from OpenStreetMap](https://www.openstreetmap.org/export#map=4/54.47/12.79) that lets you draw a bounding box on a world map to get coordinates to work with:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![OpenStreetMap's site for exporting bounding box coordinates](img/osm-export.png){fig-align='center' fig-alt='OpenStreetMap\\'s site for exporting bounding box coordinates' width=100%}\n:::\n:::\n\n\nWe can then create a [little matrix of coordinates](https://felixanalytix.medium.com/how-to-map-any-region-of-the-world-using-r-programming-bb3c4146f97f). We're ultimately going to use the [PTRA08 / LAEA Europe projection](https://epsg.io/5633), which is centered in Portugal and is a good Europe-centric projection, so we'll convert the list of coordinates to that projection.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\neurope_window <- st_sfc(\n  st_point(c(-12.4, 29.31)),  # left (west), bottom (south)\n  st_point(c(44.74, 64.62)),  # right (east), top (north)\n  crs = st_crs(\"EPSG:4326\")   # WGS 84\n) %>% \n  st_transform(crs = st_crs(\"EPSG:5633\")) %>%  # LAEA Europe, centered in Portugal\n  st_coordinates()\neurope_window\n##            X       Y\n## [1,] 2135398 1019399\n## [2,] 5912220 5020959\n```\n:::\n\n\nNow we can plot the full world map data and use `coord_sf()` to limit it to just this window:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = world_map) +\n  coord_sf(crs = st_crs(\"EPSG:5633\"),\n           xlim = europe_window[, \"X\"],\n           ylim = europe_window[, \"Y\"],\n           expand = FALSE)\n```\n\n::: {.cell-output-display}\n![World map cropped to just show part of Europe](index_files/figure-html/try-europe-window-1.png){fig-align='center' fig-alt='World map cropped to just show part of Europe' width=60%}\n:::\n:::\n\n\nNeat. Now that we know how to zoom in on Europe, we can go through the same process we did with the US—we'll convert the Middle Earth shapefiles to the European projection, center Hobbiton on Tolkien's home in Oxford, double all the distances, and shift everything around.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Convert the Tolkien home coordinates to European coordinates\ntolkien_home <- tolkien_home %>% \n  st_transform(crs = st_crs(\"EPSG:5633\"))\n\n# Convert the Hobbiton coordinates to European coordinates\nhobbiton_in_europe <- hobbiton %>% \n  st_transform(st_crs(\"EPSG:5633\"))\n\n# Find the offset between Tolkien's home and Hobbiton\nme_to_europe <- st_coordinates(tolkien_home) - st_coordinates(hobbiton_in_europe)\n\nme_places_in_europe <- places %>% \n  # Make the Middle Earth data match the Europe projection\n  st_transform(st_crs(\"EPSG:5633\")) %>%\n  # Just look at a handful of places\n  filter(NAME %in% c(\"Hobbiton\", \"Rivendell\", \"Edoras\", \"Minas Tirith\")) %>% \n  # Double the distances\n  st_set_geometry((st_geometry(.) - st_geometry(hobbiton_in_europe)) * 2 + st_geometry(hobbiton_in_europe)) %>% \n  # Shift everything around so that Hobbiton is in Oxford\n  st_set_geometry(st_geometry(.) + me_to_europe) %>% \n  # All the geometry math made us lose the projection metadata; set it again\n  st_set_crs(st_crs(\"EPSG:5633\"))\n\ncoastline_in_europe <- coastline %>% \n  st_transform(st_crs(\"EPSG:5633\")) %>%\n  st_set_geometry((st_geometry(.) - st_geometry(hobbiton_in_europe)) * 2 + st_geometry(hobbiton_in_europe)) %>% \n  st_set_geometry(st_geometry(.) + me_to_europe) %>% \n  st_set_crs(st_crs(\"EPSG:5633\"))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = world_map, fill = \"#39CCCC\", color = \"white\", linewidth = 0.25) +\n  geom_sf(data = coastline_in_europe, linewidth = 0.25) +\n  geom_sf(data = me_places_in_europe) +\n  geom_sf_label(data = filter(me_places_in_europe, NAME %in% c(\"Hobbiton\", \"Edoras\")),\n                aes(label = NAME), nudge_x = -70000, hjust = 1) +\n  geom_sf_label(data = filter(me_places_in_europe, NAME %in% c(\"Rivendell\", \"Minas Tirith\")),\n                aes(label = NAME), nudge_x = 70000, hjust = 0) +\n  coord_sf(crs = st_crs(\"EPSG:5633\"),\n           xlim = europe_window[, \"X\"],\n           ylim = europe_window[, \"Y\"],\n           expand = FALSE) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![Middle Earth locations and borders placed in Europe](index_files/figure-html/fancy-europe-me-places-1.png){fig-align='center' fig-alt='Middle Earth locations and borders placed in Europe' width=100%}\n:::\n:::\n\n\nWith Hobbiton in Oxford, Rivendell is in north central Germany (near Hanover?), with Rohan in Switzerland and Gondor on the border of Croatia and Bosnia.\n\n\n# Things I want to do someday but am not smart enough to do\n\nAnd there's our quick tour of {sf} and Middle Earth! It's incredible how much GIS-related stuff you can do with R, and the plots are all beautiful thanks to the magic of ggplot!\n\n## Paths\n\nIt would be really cool to be able to plot the pathways different characters took in each of the books (Bilbo and Thorin's company; Frodo and Sam; Aragorn, Legolas, and Gimli, etc.). This data exists! [The LOTR Project has detailed maps](http://lotrproject.com/map/#zoom=3&lat=-1315.5&lon=1500&layers=BTTTTT) with the pathways of all of the main characters' journeys. However, it's not (as far as I can tell) open source or Creative Commons-licensed, and I don't think the coordinates are directly comparable to the shapefiles from the ME-GIS project. Alas.\n\n## First and Second Ages\n\nIn addition to *The Lord of the Rings* and *The Hobbit*, Tolkien wrote a ton about other ages in Middle Earth (see this [super quick crash course in the Ages of Arda from my post on Númenorean ages](https://www.andrewheiss.com/blog/2023/03/21/aragorn-dunedan-numenorean-simulation/#super-quick-crash-course-in-the-ages-of-arda-n%C3%BAmenor)). A separate mapping project—[Arda-Maps](https://github.com/kwoxer/Arda-Maps)—has shapefiles for all three ages of Tolkien's world, including Valinor, Beleriand, and Númenor. \n\nHowever, the maps aren't as detailed as the ME-GIS project, and they're on a completely different scale. For example, here's the island of Númenor (featured in Amazon's *The Rings of Power*). I downloaded the shapefiles from their [GitHub repository](https://github.com/kwoxer/Arda-Maps)—the Second Age shapefiles are buried in `QGIS/second age/arda2`\n\nHere I use `st_bbox()` to create a bounding box of coordinates that I then use to crop the underlying data. This is different from what we did with Europe, where we plotted the whole world map and then zoomed in on just a chunk of western Europe. Here, `st_crop()` cuts out the geographic data that doesn't fall within the box (similar to filtering).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnumenor_box <- st_bbox(c(xmin = 0.007, xmax = 0.017, ymin = -0.025, ymax = -0.015))\n\nnumenor_outlines <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/poly_outline.shp\") %>% \n  filter(name == \"Numenor\")\n\nnumenor_rivers <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/line_river.shp\") %>% \n  st_crop(numenor_box)\n\nnumenor_cities <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/point_city.shp\") %>% \n  st_crop(numenor_box)\n\nggplot() +\n  geom_sf(data = numenor_outlines, fill = \"#F2CB9B\") +\n  geom_sf(data = numenor_rivers, linewidth = 0.4, color = clr_blue) +\n  geom_sf(data = numenor_cities) +\n  # Use geom_label_repel with the geometry column!\n  ggrepel::geom_label_repel(\n    data = numenor_cities, \n    aes(label = eventname, geometry = geometry),\n    stat = \"sf_coordinates\", seed = 1234,\n    family = \"Overpass ExtraBold\") +\n  annotation_scale(location = \"tl\", bar_cols = c(\"grey30\", \"white\"),\n                   text_family = \"Overpass\",\n                   unit_category = \"imperial\") +\n  annotation_north_arrow(\n    location = \"tl\", pad_y = unit(1.5, \"lines\"),\n    style = north_arrow_fancy_orienteering(fill = c(\"grey30\", \"white\"), \n                                           line_col = \"grey30\",\n                                           text_family = \"Overpass\")) +\n  labs(title = \"Númenor\") +\n  theme_void() +\n  theme(plot.background = element_rect(fill = clr_yellow),\n        plot.title = element_text(family = \"Aniron\", size = rel(2), \n                                  hjust = 0.02))\n```\n\n::: {.cell-output-display}\n![Fancy map of Númenor](index_files/figure-html/numenor-map-1.png){fig-align='center' fig-alt='Fancy map of Númenor' width=100%}\n:::\n:::\n\n\nThe map looks fantastic! But notice the scale bar in the top left corner—in this data, Númenor is only a couple thousand feet wide—less than half a mile. The distances are all way wrong. I could probably scale it up by comparing the projection distances in the Arda Maps' version of regular Middle Earth with the ME-GIS project's version of regular Middle Earth and then do some fancy math, ~~but that goes beyond my skills~~. \n\n# Update! Second Age maps scaled to Real World distances!\n\nJust kidding! Scaling stuff up doesn't go beyond my skills. We'll do it.\n\nWe already converted the data from ME-GIS into Real World miles by doubling all the coordinates centered on Hobbiton, which became the de facto center of the world. We'll do it again here since all those calculations happened way earlier in this post:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load the shapefile\nplacenames <- read_sf(\"data/ME-GIS/Combined_Placenames.shp\") %>% \n  mutate(across(where(is.character), ~iconv(., from = \"ISO-8859-1\", to = \"UTF-8\")))\n\n# Pull out Hobbiton\nhobbiton <- placenames %>% filter(NAME == \"Hobbiton\")\n\n# Double all the distances\nplaces_ta_scaled <- placenames %>%\n  # Take the existing coordinates, subtract the doubled Hobbiton coordinates,\n  # and add the Hobbiton coordinates\n  st_set_geometry((st_geometry(.) - st_geometry(hobbiton)) * 2 + st_geometry(hobbiton)) %>%\n  st_set_crs(st_crs(placenames))\n\n# Confirm that it's 458 miles between Hobbiton and Rivendell\nhobbiton_ta <- places_ta_scaled %>% filter(NAME == \"Hobbiton\")\nrivendell_ta <- places_ta_scaled %>% filter(NAME == \"Rivendell\")\n\n# Use set_units() just for fun since st_distance returns the units as metadata\nst_distance(hobbiton_ta, rivendell_ta) %>% units::set_units(\"miles\")\n## Units: [miles]\n##      [,1]\n## [1,]  458\n```\n:::\n\n\nThe Second Age data doesn't have Hobbiton in it since Hobbits didn't exist yet (you can see the [Harfoots](https://lotr.fandom.com/wiki/Harfoots), Amazon's version of proto-Hobbits, in *The Rings of Power*), but it does have Bree, which is a village near the Shire.\n\nSo first, we'll find the distance between Bree and Rivendell:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbree_ta <- places_ta_scaled %>% filter(NAME == \"Bree\")\nbree_to_rivendell_ta <- st_distance(bree_ta, rivendell_ta)\nbree_to_rivendell_ta %>% units::set_units(\"miles\")\n## Units: [miles]\n##      [,1]\n## [1,]  360\n```\n:::\n\n\n360 miles. Lovely.\n\nNext, let's see how far apart Bree and Rivendell are in the Arda-Maps Second Age map. We'll reload the data and convert the projection to use the same CRS as the ME-GIS map so that things are comparable.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsa_cities <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/point_city.shp\") %>% \n  st_transform(st_crs(placenames))\n\nrivendell_sa <- sa_cities %>% filter(eventname == \"Rivendell\")\nbree_sa <- sa_cities %>% filter(eventname == \"Bree\")\n\nbree_to_rivendell_sa <- st_distance(bree_sa, rivendell_sa)\nbree_to_rivendell_sa %>% units::set_units(\"miles\")\n## Units: [miles]\n##       [,1]\n## [1,] 0.166\n```\n:::\n\n\nHahaha, in this tiny map, it's only a sixth of a mile between Bree and Rivendell. Assuming there are 2,000 steps in a mile, that's only 333 steps, which is just a little more than what Fitbits and Apple Watches try to make you do over the course of an hour. \n\nWe need to turn this sixth of a mile into 360 miles, which involves dividing by… something. I always forget how to rescale things, so I find it helpful to write out the algebra for it:\n\n$$\n\\begin{aligned}\n0.1666x &= 360 \\\\\nx &= \\frac{360}{0.1666} \\\\\nx &= 2160\\text{ish}\n\\end{aligned}\n$$\n\nIf we multiply everything in the Second Age map data by 2160ish, we should be good. First we'll get the official, more precise number (since we're missing decimals in the quick algebra above):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsa_to_ta_conversion <- as.numeric(bree_to_rivendell_ta / bree_to_rivendell_sa)\nsa_to_ta_conversion\n## [1] 2174\n```\n:::\n\n\nNext we'll scale up the Second Age map data, using Bree as the central reference point:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsa_cities_scaled <- sa_cities %>% \n  st_set_geometry((st_geometry(.) - st_geometry(bree_sa)) * sa_to_ta_conversion + st_geometry(bree_sa)) %>% \n  st_set_crs(st_crs(placenames))\n```\n:::\n\n\nFinally let's make sure it worked. We're looking for 360 miles:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrivendell_sa_scaled <- sa_cities_scaled %>% filter(eventname == \"Rivendell\")\nbree_sa_scaled <- sa_cities_scaled %>% filter(eventname == \"Bree\")\n\nst_distance(bree_sa_scaled, rivendell_sa_scaled) %>% units::set_units(\"miles\")\n## Units: [miles]\n##      [,1]\n## [1,]  360\n```\n:::\n\n\nIt worked!\n\nNow we can plot this thing. Since we're working with a different projection, the bounding box (`numenor_box`) that we previously made for cropping the shapefiles won't work. But we can be even more precise by extracting the bounding box from the Númenor outlines and then using *that* as the cropping box.\n\nAlso, we'll add some more layers to the map for fun, but because this rescaling business can get repetitive and tedious, we'll make a little function to cut down on repetition.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnumenor_outlines <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/poly_outline.shp\") %>% \n  st_transform(st_crs(placenames)) %>% \n  filter(name == \"Numenor\")\n\n# Extract the bounds for Númenor so we can crop everything else with it\nnumenor_bbox <- st_bbox(numenor_outlines)\n\n# Little helper function to scale things from the Second Age to the real world\nscale_sa_to_real_world <- function(x) {\n  x %>% \n    st_set_geometry((st_geometry(.) - st_geometry(bree_sa)) * as.numeric(sa_to_ta_conversion) + st_geometry(bree_sa)) %>% \n    st_set_crs(st_crs(placenames))\n}\n\nnumenor_outlines_scaled <- numenor_outlines %>% \n  scale_sa_to_real_world()\n\nnumenor_rivers_scaled <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/line_river.shp\") %>% \n  st_transform(st_crs(placenames)) %>% \n  st_crop(numenor_bbox) %>% \n  scale_sa_to_real_world()\n\nnumenor_cities_scaled <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/point_city.shp\") %>% \n  st_transform(st_crs(placenames)) %>% \n  st_crop(numenor_bbox) %>% \n  scale_sa_to_real_world()\n\nnumenor_forests_scaled <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/poly_forest.shp\") %>% \n  st_transform(st_crs(placenames)) %>% \n  st_crop(numenor_bbox) %>% \n  scale_sa_to_real_world()\n\nnumenor_highlands_scaled <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/poly_highland.shp\") %>% \n  st_transform(st_crs(placenames)) %>% \n  st_crop(numenor_bbox) %>% \n  scale_sa_to_real_world()\n\nnumenor_regions_scaled <- read_sf(\"data/Arda-Maps/QGIS/second age/arda2/poly_region.shp\") %>% \n  st_transform(st_crs(placenames)) %>% \n  st_crop(numenor_bbox) %>% \n  scale_sa_to_real_world()\n```\n:::\n\n\nMapping time!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  # Background of the island\n  geom_sf(data = numenor_outlines_scaled, linewidth = 0, fill = \"#F2CB9B\") +\n  geom_sf(data = numenor_forests_scaled, \n          linewidth = 0, fill = clr_green, alpha = 0.4) +\n  geom_sf(data = numenor_highlands_scaled, \n          linewidth = 0, fill = colorspace::darken(\"#F2CB9B\", 0.1)) +\n  geom_sf(data = numenor_rivers_scaled, linewidth = 0.4, color = clr_blue) +\n  # Region borders\n  geom_sf(data = numenor_regions_scaled, linewidth = 0.2, linetype = \"33\", fill = NA) +\n  # Island borders to cover up the dotted region lines on the coast\n  geom_sf(data = numenor_outlines_scaled, linewidth = 0.25, fill = NA) +\n  geom_sf_text(data = filter(numenor_regions_scaled, eventname != \"Mittalmar\"), \n               aes(label = eventname),\n               family = \"Overpass Heavy\", size = 5, color = \"grey30\") +\n  geom_sf_text(data = filter(numenor_regions_scaled, eventname == \"Mittalmar\"), \n               aes(label = eventname),\n               family = \"Overpass Heavy\", size = 5, color = \"grey30\",\n               nudge_y = miles_to_meters(30)) +\n  geom_sf(data = numenor_cities_scaled) +\n  ggrepel::geom_label_repel(\n    data = numenor_cities_scaled, \n    aes(label = eventname, geometry = geometry),\n    stat = \"sf_coordinates\", seed = 1234,\n    family = \"Overpass ExtraBold\") +\n  annotation_scale(location = \"tl\", bar_cols = c(\"grey30\", \"white\"),\n                   text_family = \"Overpass\",\n                   unit_category = \"imperial\",\n                   width_hint = 0.3) +\n  annotation_north_arrow(\n    location = \"tl\", pad_y = unit(1.5, \"lines\"),\n    style = north_arrow_fancy_orienteering(fill = c(\"grey30\", \"white\"), \n                                           line_col = \"grey30\",\n                                           text_family = \"Overpass\")) +\n  labs(title = \"Númenor\") +\n  theme_void() +\n  theme(plot.background = element_rect(fill = \"#bacdf7\"),\n        plot.title = element_text(family = \"Aniron\", size = rel(2), \n                                  hjust = 0.02))\n```\n\n::: {.cell-output-display}\n![Correctly scaled fancy map of Númenor](index_files/figure-html/numenor-map-correct-1.png){fig-align='center' fig-alt='Correctly scaled fancy map of Númenor' width=100%}\n:::\n:::\n\n\nWe can compare it with Karen Wynn Fonstad's map of Númenor from page 43 in [*Atlas of Middle-earth*](https://www.amazon.com/Atlas-Middle-Earth-Revised-Karen-Fonstad/dp/0618126996) and the scaling all seems correct—the island is about 600 miles wide in both the book and in the data.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Karen Wynn Fonstad's map of Númenor](img/numenor-fonstad.png){fig-align='center' fig-alt='Karen Wynn Fonstad\\'s map of Númenor' width=100%}\n:::\n:::\n\n\nSuccess!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"../../../../../site_libs/jquery-1.12.4/jquery.min.js\"></script>\n<link href=\"../../../../../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"../../../../../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"../../../../../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"../../../../../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../site_libs/leaflet-binding-2.1.2/leaflet.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}