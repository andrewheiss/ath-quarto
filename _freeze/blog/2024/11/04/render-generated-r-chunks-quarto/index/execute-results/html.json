{
  "hash": "14e557100aaa1e8187fd7f0f7eb870ec",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Guide to generating and rendering computational markdown content programmatically with Quarto\"\ndate: 2024-11-04\ndsecription: \"Learn how to use `knitr::knit()` in inline chunks to correctly render auto-generated R and markdown content in Quarto documents\"\nimage: \"img/continent-reports.png\"\ntwitter-card:\n  image: \"img/continent-reports.png\"\nopen-graph:\n  image: \"img/continent-reports.png\"\ncategories:\n  - r\n  - quarto\n  - markdown\ndoi: 10.59350/pa44j-cc302\ncitation: true\n---\n\n\n\n\n\nThis year, I've helped build the Idaho Secretary of State's office's election results website for both the primary and general elections. Working with election data is a complex process, with each precinct reporting results to their parent counties, which all use different systems and software and candidate identifiers. Those county results then go into a central state-level database that state officials have access to for analysis and reporting.\n\nIn 2024, Idaho used a [Quarto website](https://quarto.org/docs/websites/) to present the results for each statewide, congressional, and legislative contest (the URL is [results.voteidaho.gov](https://results.voteidaho.gov/), though the Quarto website part probably won't live there forever):\n\n![](img/website-screenshot.png){.border .rounded}\n\nI may write something up someday about the process of building the website, depending on NDAs and security and copyright arrangements and whatnot. There are some neat technical details involved in the whole process, like [complex static {targets} branching](https://books.ropensci.org/targets/static.html), [remote {targets} storage](https://books.ropensci.org/targets/cloud-storage.html), and replicating the structure of the real, live results database with a [local DuckDB database](https://duckdb.org/) for testing things without connecting to the live database. The short, sanitized version is that it uses two [{targets} pipelines](https://books.ropensci.org/targets/):\n\n1. An [ETL](https://en.wikipedia.org/wiki/Extract,_transform,_load) pipeline connects to the central results database, retrieves the latest results for each contest, standardizes the idenfitiers and cleans up the results, generates summary tables and maps for each race, and pushes the cleaned results to a shared datastore.\n2. A website pipeline grabs the latest cleaned results from the shared datastore and builds a Quarto website.\n\nThe two pipelines run independently of each other every few minutes, and thanks to the magic of {targets}, if there are no updates (i.e. if there's a lull in the reporting on election night), nothing needs to rebuild. It's really neat.\n\nThere's one Quarto/R Markdown trick that I used extensively when building the site: it's possible to use R to automatically generate Quarto markdown *before* the entire document runs, allowing you to create parameterized templates for repeated elements. \n\nEach race uses a [tabset to show panels](https://quarto.org/docs/interactive/layout.html#tabset-panel) for (1) a table and (2) an interactive map of the results, and the reporting status for all the counties involved in the race is included in a [callout block](https://quarto.org/docs/authoring/callouts.html).\n\n::: {.panel-tabset}\n### Results table\n\n![](img/race-example-tbl.png){.border .rounded width=\"80%\" fig-align=\"center\"}\n\n### Results map\n\n![](img/race-example-map.png){.border .rounded width=\"80%\" fig-align=\"center\"}\n:::\n\nThe markdown for each of these race results sections looks something like this:\n\n````default\n## Parent district\n\n::: {.callout-note title=\"X/Y counties fully reported\" collapse=\"true\"}\n**Complete**: list of counties\n\n**In progress**: list of counties\n:::\n\n### Race name\n\n::: {.panel-tabset}\n#### Table\n\n```{{r}}\n# R code for creating the table\n```\n\n#### Map\n\n```{{r}}\n# R code for creating the map\n```\n:::\n````\n\nFor pages where there's only one race, like the presidential election and the state's constitutional amendment election, it's trivial enough to just copy/paste that general template and replace the corresponding R code. But for the state-level legislative page, there are dozens of races. Repeating and modifying all that markdown 100+ times would be *miserable*. So instead, we programmatically generate the markdown for each race before the site is rendered so that Quarto thinks it's working with hand-typed markdown.\n\nGenerating big chunks of markdown like this is a really cool approach with all sorts of applications (generate sections of a website; generate panel tabsets; generate presentation slides; etc.), but it's a little unwieldly at first. So in this post, I'll (1) show why this is trickier than just using regular R chunks with `results=\"asis\"`, (2) present a detailed step-by-step explanation of how to pre-render generated computational chunks, (3) provide a shorter, simpler, less-annotated example, and (4) give a more complex, less-annotated example.\n\n\n## Why not just use `results=\"asis\"`?\n\nIt's easy to use R/Python chunks to generate HTML or LaTeX or Typst or markdown and have that output appear in the rendered document—this is essentially what table-making packages like [{tinytable}](https://vincentarelbundock.github.io/tinytable/), [{gt}](https://gt.rstudio.com/), and [{kableExtra}](https://haozhu233.github.io/kableExtra/) all do. To illustrate this, let's load {gapminder} data:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(glue)\nlibrary(gapminder)\n\ngapminder_2007 <- gapminder |> filter(year == 2007)\n```\n:::\n\n\n\nWe can create a markdown list of all the continents in the dataset. Here I do it with `paste0()`, but I could also use a nicer wrapper like [{pander}](https://rapporter.github.io/pander/), which includes all sorts of functions for generating markdown.\n\nThis correctly makes a list, but it doesn't get rendered like a list—it's displayed as code chunk output:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinents <- gapminder_2007 |> \n  distinct(continent) |> \n  pull(continent)\n\ncat(paste0(\"- \", continents, collapse = \"\\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n- Asia\n- Europe\n- Africa\n- Americas\n- Oceania\n```\n\n\n:::\n:::\n\n\n\nWe can tell Quarto to treat the output of that chunk as raw markdown instead by setting [the `results=\"asis\"` chunk option](https://quarto.org/docs/reference/cells/cells-knitr.html#cell-output): \n\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r}}\n#| results: asis\ncat(paste0(\"- \", continents, collapse = \"\\n\"))\n```\n````\n\n- Asia\n- Europe\n- Africa\n- Americas\n- Oceania\n:::\n\n\n\nThat's great and normal and I use this approach all the time for generating non-computational markdown.\n\nWhere this doesn't work is when you have R chunks that need to be computed. To show this, let's make a list showing π rounded to different digits using [inline code chunks](https://quarto.org/docs/computations/inline-code.html). We can manually type it like this:\n\n```markdown\n- `r round(pi, 1)`\n- `r round(pi, 2)`\n- `r round(pi, 3)`\n- `r round(pi, 4)`\n- `r round(pi, 5)`\n```\n\n…which renders like this:\n\n- 3.1\n- 3.14\n- 3.142\n- 3.1416\n- 3.1416\n\nBut that's a lot of typing. So let's generate it automatically. I'll do this in a data frame, just because I like working that way, but you could also use standalone vectors (or even—gasp—a loop!):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npi_stuff <- tibble(digits = 1:5) |> \n  mutate(list_element = paste0(\"- `r round(pi, \", digits, \")`\"))\n\n# Everything is in the list_element column:\npi_stuff\n## # A tibble: 5 × 2\n##   digits list_element      \n##    <int> <chr>             \n## 1      1 - `r round(pi, 1)`\n## 2      2 - `r round(pi, 2)`\n## 3      3 - `r round(pi, 3)`\n## 4      4 - `r round(pi, 4)`\n## 5      5 - `r round(pi, 5)`\n```\n:::\n\n\n\nWe can put that column in a `results=\"asis\"` chunk…\n\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r}}\n#| results: asis\ncat(paste0(pi_stuff$list_element, collapse = \"\\n\"))\n```\n````\n\n- `r round(pi, 1)`\n- `r round(pi, 2)`\n- `r round(pi, 3)`\n- `r round(pi, 4)`\n- `r round(pi, 5)`\n:::\n\n\n\n…and it renders correctly as markdown, but it doesn't run the inline chunks :(\n\nThis is because of an issue with ordering: Quarto renders the chunk with `cat(paste0(...))` and then moves on to the next chunk in the document. It won't render the R chunks that the `pi_stuff$list_element` object contains because they're all nested inside the parent chunk, and Quarto's rendering process has moved on by the time the newly generated R chunks appear.\n\nThe trick is to pre-render the chunks before they officially show up in the document.^[I haven't found this formally documented anywhere—I stumbled across this approach in [this gist from 2015](https://gist.github.com/StevenMMortimer/e54ec050d97d79996189).] We can feed the collapsed `pi_stuff$list_element` object to `knitr::knit()` in an inline chunk, which makes Quarto render all the R chunks inside the chunk first, then place the output in the document to be rendered in the correct order like normal chunks:\n\n````markdown\nHere's some regular markdown text. Let's show a list of \ndifferently-rounded values of $\\pi$ for fun:\n\n`r knitr::knit(text = paste0(pi_stuff$list_element, collapse = \"\\n\"))`\n\nIsn't that neat?\n````\n\nThat markdown will render to this:\n\n::: {.callout-tip appearance=\"simple\" icon=\"false\"}\nHere's some regular markdown text. Let's show a list of \ndifferently-rounded values of $\\pi$ for fun:\n\n- 3.1\n- 3.14\n- 3.142\n- 3.1416\n- 3.1416\n\nIsn't that neat?\n:::\n\n\n## Building a panel tabset with an inline chunk\n\n*Technically* there was no need to use `knitr::knit()` in an inline chunk for that previous example. It would be easier to generate the text output within the `pi_stuff` data frame instead of in a bunch of inline chunks, and then show the results like normal with `results=\"asis\"`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r}}\n#| results: asis\npi_stuff_easier <- tibble(digits = 1:5) |> \n  mutate(list_element = paste0(\"- \", round(pi, digits)))\n\ncat(paste0(pi_stuff_easier$list_element, collapse = \"\\n\"))\n```\n````\n\n- 3.1\n- 3.14\n- 3.142\n- 3.1416\n- 3.14159\n:::\n\n\n\nHowever, using `knitr::knit(text = BLAH)` in an inline chunk like this is a powerful trick that lets you do all sorts of more complex document generation automation. Let's make a more complicated example with real data instead of a bunch of π rounding.\n\nFor this example, let's make a panel tabset with a plot for each continent in the `gapminder_2007` dataset we made earlier.\n\nFirst, we'll make a list of plots. This can be done any number of ways—I like using `group_by() |> nest()` and {purrr} functions like `map()`, but any way will work as long as you have a list of ggplot objects in the end.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinents_plots <- gapminder_2007 |> \n  group_by(continent) |> \n  nest() |> \n  ungroup() |> \n  # We could use map2(), but I like using pmap() just in case I need to\n  # expand it beyond 2 things\n  mutate(plot = pmap(\n    lst(data, continent), \n    \\(data, continent) {\n      plot_title <- paste0(\"Health and wealth in \", continent)\n      ggplot(data, aes(x = gdpPercap, y = lifeExp)) +\n        geom_point() +\n        scale_x_log10(labels = scales::label_dollar(accuracy = 1)) +\n        labs(title = plot_title)\n    }))\n\ncontinents_plots\n## # A tibble: 5 × 3\n##   continent data              plot  \n##   <fct>     <list>            <list>\n## 1 Asia      <tibble [33 × 5]> <gg>  \n## 2 Europe    <tibble [30 × 5]> <gg>  \n## 3 Africa    <tibble [52 × 5]> <gg>  \n## 4 Americas  <tibble [25 × 5]> <gg>  \n## 5 Oceania   <tibble [2 × 5]>  <gg>\n```\n:::\n\n\n\nThe plots are all in the `plot` column in `continents_plots`, which is a list of ggplot objects. Here's one of them:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinents_plots$plot[[3]]\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\nTo make a tabset with a panel for each continent, we need to write markdown like this:\n\n````markdown\n::: {.panel-tabset}\n### Continent 1\n\n```{{r}}\n#| label: panel-continent-a\n#| echo: false\ncontinents_plots$plot[[1]]\n```\n\n### Continent 2\n\n```{{r}}\n#| label: panel-continent-b\n#| echo: false\ncontinents_plots$plot[[2]]\n```\n\n### (…and so on…)\n\n:::\n````\n\nWe could just copy/paste those continent sections over and over, but that's tedious and not very dynamic. Instead, we can create a little markdown template for each panel and generate all these chunks. To do that, we'll use [{glue}](https://glue.tidyverse.org/), which is a lot nicer for building strings than using `paste0()`, since it uses Python-style string interpolation. `glue::glue()` replaces any text inside `{}`s with the corresponding variable value:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Some values\nanimals <- \"cats\"\nnumber <- 12\nlocation <- \"house\"\n\n# Ugly paste() way\npaste0(\"There are \", number, \" blue \", animals, \" in the \", location)\n## [1] \"There are 12 blue cats in the house\"\n\n# Nice glue() way\nglue(\"There are {number} blue {animals} in the {location}\")\n## There are 12 blue cats in the house\n```\n:::\n\n\n\nIf you need to use literal curly braces in the text, you can either double them or change the delimiters:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npkg_name <- \"ggplot2\"\n\n# The curly braces disappear\nglue(\"The {pkg_name} package is delightful\")\n## The ggplot2 package is delightful\n\n# Double them to keep them\nglue(\"The {{{pkg_name}}} package is delightful\")\n## The {ggplot2} package is delightful\n\n# Or change the delimiter\nglue(\"The {<<pkg_name>>} package is delightful\", .open = \"<<\", .close = \">>\")\n## The {ggplot2} package is delightful\n```\n:::\n\n\n\nBeing able to change the delimiter is useful since we'll need to generate chunks that start with <code>```{r}</code>. \n\nWe can use `glue()` in a function that takes a continent name and a row number and generates a markdown tabset panel:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbuild_panel <- function(panel_title, plot_index) {\n  chunk_label <- glue(\"panel-continent-{title}\", title = janitor::make_clean_names(panel_title))\n\n  output <- glue(\"\n  ### <<panel_title>>\n\n  ```{r}\n  #| label: <<chunk_label>>\n  #| echo: false\n  continents_plots$plot[[<<plot_index>>]]\n  ```\", .open = \"<<\", .close = \">>\")\n\n  output\n}\n```\n:::\n\n\n\nFirst let's make sure it works by itself:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbuild_panel(\"Africa\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```` markdown\n### Africa\n\n```{r}\n#| label: panel-continent-africa\n#| echo: false\ncontinents_plots$plot[[3]]\n```\n````\n\n\n:::\n:::\n\n\n\nYep!\n\nNow we can iterate through the data frame of all the continents (`continents_plots`) and make a column that contains the markdown panel text.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinents_plots_with_text <- continents_plots |> \n  mutate(row = row_number()) |> \n  mutate(markdown = pmap_chr(\n    lst(continent, row), \n    \\(continent, row) build_panel(panel_title = continent, plot_index = row)\n  ))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinents_plots_with_text\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```` default\n# A tibble: 5 × 5\n  continent data              plot     row markdown                                                                                                   \n  <fct>     <list>            <list> <int> <chr>                                                                                                      \n1 Asia      <tibble [33 × 5]> <gg>       1 \"### Asia\\n\\n```{r}\\n#| label: panel-continent-asia\\n#| echo: false\\ncontinents_plots$plot[[1]]\\n```\"      \n2 Europe    <tibble [30 × 5]> <gg>       2 \"### Europe\\n\\n```{r}\\n#| label: panel-continent-europe\\n#| echo: false\\ncontinents_plots$plot[[2]]\\n```\"  \n3 Africa    <tibble [52 × 5]> <gg>       3 \"### Africa\\n\\n```{r}\\n#| label: panel-continent-africa\\n#| echo: false\\ncontinents_plots$plot[[3]]\\n```\"  \n4 Americas  <tibble [25 × 5]> <gg>       4 \"### Americas\\n\\n```{r}\\n#| label: panel-continent-americas\\n#| echo: false\\ncontinents_plots$plot[[4]]\\n`…\n5 Oceania   <tibble [2 × 5]>  <gg>       5 \"### Oceania\\n\\n```{r}\\n#| label: panel-continent-oceania\\n#| echo: false\\ncontinents_plots$plot[[5]]\\n```\"\n````\n\n\n:::\n:::\n\n\n\nCheck out that new `markdown` column—it has a third level heading with the continent name, followed by an R chunk that will display the corresponding plot object from `continents_plots`. Here's what one panel looks like:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncat(continents_plots_with_text$markdown[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```` markdown\n### Asia\n\n```{r}\n#| label: panel-continent-asia\n#| echo: false\ncontinents_plots$plot[[1]]\n```\n````\n\n\n:::\n:::\n\n\n\nFinally, we need to concatenate that column into one big string and include it as an inline chunk inside Quarto's syntax for tabsets:\n\n````markdown\nHealth and wealth are related in each continent.\n\n::: {.panel-tabset}\n\n`r knitr::knit(text = paste0(continents_plots_with_text$markdown, collapse = \"\\n\\n\"))`\n\n:::\n\nAutomatic tabset panels!\n````\n\nHere's what it looks like when rendered:\n\n:::: {.callout-tip appearance=\"simple\" icon=\"false\"}\nHealth and wealth are related in each continent.\n\n::: {.panel-tabset}\n\n### Asia\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/panel-continent-asia-1.png){fig-align='center' width=95%}\n:::\n:::\n\n### Europe\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/panel-continent-europe-1.png){fig-align='center' width=95%}\n:::\n:::\n\n### Africa\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/panel-continent-africa-1.png){fig-align='center' width=95%}\n:::\n:::\n\n### Americas\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/panel-continent-americas-1.png){fig-align='center' width=95%}\n:::\n:::\n\n### Oceania\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/panel-continent-oceania-1.png){fig-align='center' width=95%}\n:::\n:::\n\n:::\n\nAutomatic tabset panels!\n::::\n\nPerfect! We successfully generated a bunch of R chunks, pre-rendered them with Quarto, and then rendered the rest of the document.\n\n\n## Condensed example showing the evolution of a ggplot plot\n\nNow that we've walked through the general process in detail, we'll look at a less didactic example. Suppose you want to show the step-by-step process of creating a ggplot plot in a tabset panel or in a [Revealjs Quarto slideshow](https://quarto.org/docs/presentations/revealjs/). You could manually copy/paste a bunch of markdown over and over (ew), or you could generate chunks and make Quarto make the panels or slides for you (yay).\n\nFirst we'll make a list of plots. There's actually a neat new package—[{ggreveal}](https://www.weverthon.com/ggreveal/)—that can create a list of intermediate plots automatically, but I'll just do it manually here (though this process will work the same with {ggreveal}).\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- ggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point()\np1_text <- glue(\"\n  ggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n    geom_point()\")\n\np2 <- p1 + \n  scale_x_log10(labels = scales::dollar_format(accuracy = 1))\np2_text <- glue(\"\n  {p1_text} +\n    scale_x_log10(labels = scales::dollar_format(accuracy = 1))\n\")\n\np3 <- p2 + \n  scale_color_viridis_d(option = \"plasma\", end = 0.9)\np3_text <- glue('\n  {p2_text} +\n    scale_color_viridis_d(option = \"plasma\", end = 0.9)\n')\n\np4 <- p3 + \n  theme_minimal()\np4_text <- glue('\n  {p3_text} +\n    theme_minimal()\n')\n\np5 <- p4 + \n  labs(x = \"GDP per capita\", y = \"Life expectancy\", color = \"Continent\")\np5_text <- glue('\n  {p4_text} +\n    labs(x = \"GDP per capita\", y = \"Life expectancy\", color = \"Continent\")\n')\n\nplot_list <- list(p1, p2, p3, p4, p5)\nplot_text <- list(p1_text, p2_text, p3_text, p4_text, p5_text)\n\nplot_list <- tribble(\n  ~plot, ~code_text, ~description,\n  p1, p1_text, \"Start with the initial plot…\",\n  p2, p2_text, \"…use a logarithmic x-axis…\",\n  p3, p3_text, \"…change the color palette…\",\n  p4, p4_text, \"…change the theme…\",\n  p5, p5_text, \"…and change the default labels\"\n)\n```\n:::\n\n\n\nWe want the overall tabset to look something like this:\n\n````markdown\n::: {.panel-tabset}\n\n### Step 1\n\nShort description\n\n```{{r}}\nplot_list[[1]]\n```\n\n```r\n# Code here\n```\n\n### Step 2\n\nShort description\n\n```{{r}}\nplot_list[[2]]\n```\n\n```r\n# Code here\n```\n\n### …and so on\n\n:::\n````\n\n…so next we'll generate markdown for each panel:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npanels <- map_chr(\n  seq_len(nrow(plot_list)), \n  \\(i) {\n    glue(\"\n    ### Step <<i>>\n\n    `r plot_list$description[[<<i>>]]`\n\n    ```{r}\n    #| label: plot-panel-<<i>>\n    #| echo: false\n    plot_list$plot[[<<i>>]]\n    ```\n\n    ```r\n    `r plot_list$code_text[[<<i>>]]`\n    ```\", .open = \"<<\", .close = \">>\")\n  }\n)\n```\n:::\n\nFinally we'll wrap Quarto's special markdown syntax for tabsets around these panels and then include the combined text as an inline chunk in the document:\n\n````markdown\nLet's slowly build up the plot:\n\n::: {.panel-tabset}\n\n`r knitr::knit(text = paste0(panels, collapse = \"\\n\\n\"))`\n\n:::\n````\n\n:::: {.callout-tip appearance=\"simple\" icon=\"false\"}\nLet's slowly build up the plot:\n\n::: {.panel-tabset}\n\n### Step 1\n\nStart with the initial plot…\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-panel-1-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n```r\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point()\n```\n\n### Step 2\n\n…use a logarithmic x-axis…\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-panel-2-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n```r\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10(labels = scales::dollar_format(accuracy = 1))\n```\n\n### Step 3\n\n…change the color palette…\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-panel-3-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n```r\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10(labels = scales::dollar_format(accuracy = 1)) +\n  scale_color_viridis_d(option = \"plasma\", end = 0.9)\n```\n\n### Step 4\n\n…change the theme…\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-panel-4-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n```r\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10(labels = scales::dollar_format(accuracy = 1)) +\n  scale_color_viridis_d(option = \"plasma\", end = 0.9) +\n  theme_minimal()\n```\n\n### Step 5\n\n…and change the default labels\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-panel-5-1.png){fig-align='center' width=95%}\n:::\n:::\n\n\n```r\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10(labels = scales::dollar_format(accuracy = 1)) +\n  scale_color_viridis_d(option = \"plasma\", end = 0.9) +\n  theme_minimal() +\n  labs(x = \"GDP per capita\", y = \"Life expectancy\", color = \"Continent\")\n```\n\n:::\n::::\n\n\n## Condensed example of continent-level mini reports\n\nFinally, let's look at one more example that's similar to what I used for the Idaho election results website, making a sort of miniature report for each continent. This time, instead of creating a tabset panel for each continent, we'll make a whole markdown section for each continent, with a tabset panel included in each.\n\nEach continent section will look something like this:\n\n````markdown\n### Continent name\n\n::: {.callout-note icon=\"false\" title=\"X countries\" collapse=\"true\"}\nComma-separated list of countries\n:::\n\n::: {.panel-tabset}\n#### Details\n\n```{{r}}\n#| label: table-summary-continent\n#| echo: false\n\n# A table showing average GDP per capita and average life expectancy\n```\n\n#### Plot\n\n```{{r}}\n#| label: plot-summary-continent\n#| echo: false\n\n# A plot showing the relationship between GDP per capita and life expectancy\n```\n:::\n````\n\nAs before, we'll translate this template into a `glue()` string, feed some data into it, and generate a bunch of R chunks.\n\n::: {.callout-tip}\n### Child documents\n\nThis template is getting gnarly with so many moving parts and so many common {glue} delimiters like `{}`s and `[]`s and `<>`s. An alternative approach to put the template in a separate child Quarto document and then pre-render it with `knitr::knit_child()`, which behaves just like the inline `knitr::knit(file = BLAH)` approach we've been using. Quarto has an official example of how to do it here: [example](https://examples.quarto.pub/create-tabsets-panel-from-r-code/) and [code](https://github.com/quarto-dev/quarto-examples/blob/main/tabsets/tabsets-from-r-chunks/index.qmd).\n:::\n\nFirst, we'll make a data frame with all the different pieces we want to include, using the same `group_by(continent) |> nest()` approach as before:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinent_report_items <- gapminder_2007 |> \n  group_by(continent) |> \n  nest() |> \n  ungroup() |> \n  mutate(country_list = map_chr(data, \\(x) knitr::combine_words(x$country))) |> \n  mutate(n_countries = map_int(data, \\(x) nrow(x))) |> \n  mutate(summary_details = map(data, \\(x) {\n    x |> \n      summarize(\n        `Average GDP per capita` = mean(gdpPercap),\n        `Average life expectancy` = mean(lifeExp),\n        `Average population` = mean(pop)\n      ) |> \n      pivot_longer(everything(), names_to = \"Statistic\", values_to = \"Value\") |> \n      mutate(Value = scales::comma_format()(Value))\n  })) |> \n  mutate(plot = map(data, \\(x) {\n    x |> \n      ggplot(aes(x = gdpPercap, y = lifeExp)) +\n        geom_point() +\n        scale_x_log10(labels = scales::label_dollar(accuracy = 1)) +\n        labs(title = glue(\"Health and wealth in {continent}\"))\n  }))\n```\n:::\n\nNext we'll make a function that generates the markdown output:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbuild_continent_report <- function(i) {\n  name_for_labels <- janitor::make_clean_names(continent_report_items$continent[[i]])\n\n  # Quarto and RStudio and Positron all really struggle with syntax highlighting \n  # and parsing when there are multiple ```s inside a string, so we can make \n  # life easier by splitting the output into a few parts here, ensuring that \n  # there's a maximum of one set of triple backticks\n\n  output_first_part <- glue('\n  ### `r continent_report_items$continent[[<<i>>]]`\n\n  ::: {.callout-note icon=\"false\" title=\"`r continent_report_items$n_countries[[<<i>>]]` countries\" collapse=\"true\"}\n  `r continent_report_items$country_list[[<<i>>]]`\n  :::', .open = \"<<\", .close = \">>\")\n\n  output_panel_details <- glue('\n  #### Details\n\n  ```{r}\n  #| label: table-summary-<<name_for_labels>>\n  #| echo: false\n\n  continent_report_items$summary_details[[<<i>>]] |>\n    knitr::kable()\n  ```', .open = \"<<\", .close = \">>\")\n\n  output_panel_plot <- glue('\n  #### Plot\n\n  ```{r}\n  #| label: plot-summary-<<name_for_labels>>\n  #| echo: false\n\n  continent_report_items$plot[[<<i>>]]\n  ```', .open = \"<<\", .close = \">>\")\n\n  # Combine all the pieces\n  output <- glue('\n  {output_first_part}\n\n  ::: {{.panel-tabset}}\n  {output_panel_details}\n\n  {output_panel_plot}\n  :::\n  ')\n\n  output\n}\n```\n:::\n\nFinally, we'll loop through each row in `continent_report_items` and generate the markdown report using the template…\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinent_reports <- map_chr(\n  seq_len(nrow(continent_report_items)), \n  \\(i) build_continent_report(i)\n)\n```\n:::\n\n\n\n…and include all the generated markdown in an inline chunk:\n\n````markdown\n## Continent reports\n\nCheck out all these automatically generated continent reports!\n\n`r knitr::knit(text = paste0(continent_reports, collapse = \"\\n\\n\"))`\n````\n\nThat single inline chunk automatically generates dozens of inline and block chunks of R code *before* the full document goes through Quarto, which means all this output gets included in the final rendered version:\n\n:::: {.callout-tip appearance=\"simple\" icon=\"false\"}\n## Generated output\n\n## Continent reports\n\nCheck out all these automatically generated continent reports!\n\n### Asia\n\n::: {.callout-note icon=\"false\" title=\"33 countries\" collapse=\"true\"}\nAfghanistan, Bahrain, Bangladesh, Cambodia, China, Hong Kong, China, India, Indonesia, Iran, Iraq, Israel, Japan, Jordan, Korea, Dem. Rep., Korea, Rep., Kuwait, Lebanon, Malaysia, Mongolia, Myanmar, Nepal, Oman, Pakistan, Philippines, Saudi Arabia, Singapore, Sri Lanka, Syria, Taiwan, Thailand, Vietnam, West Bank and Gaza, and Yemen, Rep.\n:::\n\n::: {.panel-tabset}\n#### Details\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|Statistic               |Value       |\n|:-----------------------|:-----------|\n|Average GDP per capita  |12,473      |\n|Average life expectancy |71          |\n|Average population      |115,513,752 |\n\n\n:::\n:::\n\n#### Plot\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-summary-asia-1.png){fig-align='center' width=95%}\n:::\n:::\n:::\n\n### Europe\n\n::: {.callout-note icon=\"false\" title=\"30 countries\" collapse=\"true\"}\nAlbania, Austria, Belgium, Bosnia and Herzegovina, Bulgaria, Croatia, Czech Republic, Denmark, Finland, France, Germany, Greece, Hungary, Iceland, Ireland, Italy, Montenegro, Netherlands, Norway, Poland, Portugal, Romania, Serbia, Slovak Republic, Slovenia, Spain, Sweden, Switzerland, Turkey, and United Kingdom\n:::\n\n::: {.panel-tabset}\n#### Details\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|Statistic               |Value      |\n|:-----------------------|:----------|\n|Average GDP per capita  |25,054     |\n|Average life expectancy |78         |\n|Average population      |19,536,618 |\n\n\n:::\n:::\n\n#### Plot\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-summary-europe-1.png){fig-align='center' width=95%}\n:::\n:::\n:::\n\n### Africa\n\n::: {.callout-note icon=\"false\" title=\"52 countries\" collapse=\"true\"}\nAlgeria, Angola, Benin, Botswana, Burkina Faso, Burundi, Cameroon, Central African Republic, Chad, Comoros, Congo, Dem. Rep., Congo, Rep., Cote d'Ivoire, Djibouti, Egypt, Equatorial Guinea, Eritrea, Ethiopia, Gabon, Gambia, Ghana, Guinea, Guinea-Bissau, Kenya, Lesotho, Liberia, Libya, Madagascar, Malawi, Mali, Mauritania, Mauritius, Morocco, Mozambique, Namibia, Niger, Nigeria, Reunion, Rwanda, Sao Tome and Principe, Senegal, Sierra Leone, Somalia, South Africa, Sudan, Swaziland, Tanzania, Togo, Tunisia, Uganda, Zambia, and Zimbabwe\n:::\n\n::: {.panel-tabset}\n#### Details\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|Statistic               |Value      |\n|:-----------------------|:----------|\n|Average GDP per capita  |3,089      |\n|Average life expectancy |55         |\n|Average population      |17,875,763 |\n\n\n:::\n:::\n\n#### Plot\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-summary-africa-1.png){fig-align='center' width=95%}\n:::\n:::\n:::\n\n### Americas\n\n::: {.callout-note icon=\"false\" title=\"25 countries\" collapse=\"true\"}\nArgentina, Bolivia, Brazil, Canada, Chile, Colombia, Costa Rica, Cuba, Dominican Republic, Ecuador, El Salvador, Guatemala, Haiti, Honduras, Jamaica, Mexico, Nicaragua, Panama, Paraguay, Peru, Puerto Rico, Trinidad and Tobago, United States, Uruguay, and Venezuela\n:::\n\n::: {.panel-tabset}\n#### Details\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|Statistic               |Value      |\n|:-----------------------|:----------|\n|Average GDP per capita  |11,003     |\n|Average life expectancy |74         |\n|Average population      |35,954,847 |\n\n\n:::\n:::\n\n#### Plot\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-summary-americas-1.png){fig-align='center' width=95%}\n:::\n:::\n:::\n\n### Oceania\n\n::: {.callout-note icon=\"false\" title=\"2 countries\" collapse=\"true\"}\nAustralia and New Zealand\n:::\n\n::: {.panel-tabset}\n#### Details\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|Statistic               |Value      |\n|:-----------------------|:----------|\n|Average GDP per capita  |29,810     |\n|Average life expectancy |81         |\n|Average population      |12,274,974 |\n\n\n:::\n:::\n\n#### Plot\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-summary-oceania-1.png){fig-align='center' width=95%}\n:::\n:::\n:::\n::::\n\n---\n\n↑ *that's* how we were able to generate race-specific output for 100+ individual contests for the 2024 Idaho elections. It looks messy at first, but it's a billion times easier to work with than copying/pasting markdown text and manually modifying the code in the chunks.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}