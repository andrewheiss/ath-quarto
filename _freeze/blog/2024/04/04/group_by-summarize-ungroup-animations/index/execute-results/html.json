{
  "hash": "7b47cf62b4f0e8066ec381ee1605e032",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualizing {dplyr}'s mutate(), summarize(), group_by(), and ungroup() with animations\"\ndate: 2024-04-04\ndescription: \"Visually explore how {dplyr}'s more complex core functions work together to wrangle data\"\nimage: \"downloads/PNG/grp-summarize-02@4x.png\"\ntwitter-card:\n  image: \"downloads/PNG/grp-summarize-02@4x.png\"\nopen-graph:\n  image: \"downloads/PNG/grp-summarize-02@4x.png\"\ncategories:\n  - r\n  - tidyverse\n  - dplyr\n  - animations\nresources:\n  - \"downloads/**\"\nformat:\n  html: \n    shift-heading-level-by: 1\ndoi: 10.59350/d2sz4-w4e25\ncitation: true\n---\n\n\n\n\n\n\nI've used Garrick Aden-Buie's [tidyexplain](https://www.garrickadenbuie.com/project/tidyexplain/) animations since he first made them in 2018. They're incredibly useful for teaching—being able to see which rows [`left_join()`](https://www.garrickadenbuie.com/project/tidyexplain/#left-join) includes when merging two datasets, or [which cells end up where when pivoting longer or pivoting wider](https://www.garrickadenbuie.com/project/tidyexplain/#pivot-wider-and-longer) is so valuable. [Check them all out](https://www.garrickadenbuie.com/project/tidyexplain/)—they're so fantastic:\n\n![`left_join()` animation by Garrick Aden-Buie](img/left-join.gif){.center}\n\nOne set of animations that I've always wished existed but doesn't is how {dplyr}'s `mutate()`, `summarize()`, `group_by()`, and `summarize()` work. Unlike other more straightforward {dplyr} functions like `filter()` and `select()`, these mutating/summarizing/grouping functions often involve multiple behind-the-scenes steps that are hard to see. There's even an official term for this kind of workflow: [split/apply/combine](https://vita.had.co.nz/papers/plyr.pdf).\n\nWhen I teach about `group_by() |> summarize()`, I end up waving my arms around a lot to explain how `group_by()` puts rows into smaller, invisible datasets behind the scenes. This works, I guess, but I still find that it can be hard for people to conceptualize. It gets even trickier when explaining how {dplyr} keeps some grouping structures intact after summarizing and what exactly `ungroup()` does.\n\nSo, I finally buckled down and made my own tidyexplain-esque animations with Adobe Illustrator and After Effects.^[I tried doing it with R and {gganimate} [like the original tidyexplain animations](https://github.com/gadenbuie/tidyexplain), but it was too hard to do with all the multiple grouping, summarizing, and recombining steps—so these are all artisanally handcrafted animations.]\n\n::: {.callout-tip #downloads}\n## Downloads\n\nYou can download versions of all seven animations here:\n\n- `mutate()`: [MP4](downloads/Video/grp-mutate.mp4), [GIF](downloads/GIF/grp-mutate.gif), [static PDF](downloads/PDF/grp-mutate.pdf), [static SVG](downloads/SVG/grp-mutate.svg), [static PNG](downloads/PNG/grp-mutate@4x.png)\n- `summarize()`: [MP4](downloads/Video/grp-summarize-00.mp4), [GIF](downloads/GIF/grp-summarize-00.gif), [static PDF](downloads/PDF/grp-summarize-00.pdf), [static SVG](downloads/SVG/grp-summarize-00.svg), [static PNG](downloads/PNG/grp-summarize-00@4x.png)\n- `group_by() |> ungroup()`: [MP4](downloads/Video/grp-ungroup.mp4), [GIF](downloads/GIF/grp-ungroup.gif), [static PDF](downloads/PDF/grp-ungroup.pdf), [static SVG](downloads/SVG/grp-ungroup.svg), [static PNG](downloads/PNG/grp-ungroup@4x.png)\n- `group_by() |> mutate()`: [MP4](downloads/Video/grp-mutate.mp4), [GIF](downloads/GIF/grp-mutate.gif), [static PDF](downloads/PDF/grp-mutate.pdf), [static SVG](downloads/SVG/grp-mutate.svg), [static PNG](downloads/PNG/grp-mutate@4x.png)\n- `group_by(cat1) |> summarize()`: [MP4](downloads/Video/grp-summarize-01.mp4), [GIF](downloads/GIF/grp-summarize-01.gif), [static PDF](downloads/PDF/grp-summarize-01.pdf), [static SVG](downloads/SVG/grp-summarize-01.svg), [static PNG](downloads/PNG/grp-summarize-01@4x.png)\n- `group_by(cat2) |> summarize()`: [MP4](downloads/Video/grp-summarize-02.mp4), [GIF](downloads/GIF/grp-summarize-02.gif), [static PDF](downloads/PDF/grp-summarize-02.pdf), [static SVG](downloads/SVG/grp-summarize-02.svg), [static PNG](downloads/PNG/grp-summarize-02@4x.png)\n- `group_by(cat1, cat2) |> summarize()`: [MP4](downloads/Video/grp-summarize-03.mp4), [GIF](downloads/GIF/grp-summarize-03.gif), [static PDF](downloads/PDF/grp-summarize-03.pdf), [static SVG](downloads/SVG/grp-summarize-03.svg), [static PNG](downloads/PNG/grp-summarize-03@4x.png)\n\nAnd for fun, here are all the original files:\n\n- [Original Illustrator files](downloads/illustrator-files.zip)\n- [Original After Effects files](downloads/group_by-summarize-animations.zip)\n\nThey're Creative Commons-licensed—do whatever you want with them!\n:::\n\nIn this post, we'll use these animations to explain each of these concepts and apply them to data from [{palmerpenguins}](https://allisonhorst.github.io/palmerpenguins/). Let's load some packages and data first:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\npenguins <- penguins |> drop_na()\n```\n:::\n\n\n\n\n# Adding new columns with `mutate()`\n\nThe `mutate()` function in {dplyr} adds new columns. It's not destructive—all our existing data will still be there after you add new columns^[Unless we use an existing column name inside `mutate()`, in which case that column will get replaced with the new one.]\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/mutate.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\nBy default, `mutate()` sticks the new column on the far right of the dataset (scroll over to the right to see `body_mass_kg` here):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  mutate(body_mass_kg = body_mass_g / 1000)\n## # A tibble: 333 × 9\n##    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex     year body_mass_kg\n##    <fct>   <fct>              <dbl>         <dbl>             <int>       <int> <fct>  <int>        <dbl>\n##  1 Adelie  Torgersen           39.1          18.7               181        3750 male    2007         3.75\n##  2 Adelie  Torgersen           39.5          17.4               186        3800 female  2007         3.8 \n##  3 Adelie  Torgersen           40.3          18                 195        3250 female  2007         3.25\n##  4 Adelie  Torgersen           36.7          19.3               193        3450 female  2007         3.45\n##  5 Adelie  Torgersen           39.3          20.6               190        3650 male    2007         3.65\n##  6 Adelie  Torgersen           38.9          17.8               181        3625 female  2007         3.62\n##  7 Adelie  Torgersen           39.2          19.6               195        4675 male    2007         4.68\n##  8 Adelie  Torgersen           41.1          17.6               182        3200 female  2007         3.2 \n##  9 Adelie  Torgersen           38.6          21.2               191        3800 male    2007         3.8 \n## 10 Adelie  Torgersen           34.6          21.1               198        4400 male    2007         4.4 \n## # ℹ 323 more rows\n```\n:::\n\n\n\nWe can also control where the new column shows up with either the `.before` or `.after` argument:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  mutate(\n    body_mass_kg = body_mass_g / 1000,\n    .after = island\n  )\n## # A tibble: 333 × 9\n##    species island    body_mass_kg bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex     year\n##    <fct>   <fct>            <dbl>          <dbl>         <dbl>             <int>       <int> <fct>  <int>\n##  1 Adelie  Torgersen         3.75           39.1          18.7               181        3750 male    2007\n##  2 Adelie  Torgersen         3.8            39.5          17.4               186        3800 female  2007\n##  3 Adelie  Torgersen         3.25           40.3          18                 195        3250 female  2007\n##  4 Adelie  Torgersen         3.45           36.7          19.3               193        3450 female  2007\n##  5 Adelie  Torgersen         3.65           39.3          20.6               190        3650 male    2007\n##  6 Adelie  Torgersen         3.62           38.9          17.8               181        3625 female  2007\n##  7 Adelie  Torgersen         4.68           39.2          19.6               195        4675 male    2007\n##  8 Adelie  Torgersen         3.2            41.1          17.6               182        3200 female  2007\n##  9 Adelie  Torgersen         3.8            38.6          21.2               191        3800 male    2007\n## 10 Adelie  Torgersen         4.4            34.6          21.1               198        4400 male    2007\n## # ℹ 323 more rows\n```\n:::\n\n\n\n\n# Summarizing with `summarize()`\n\nThe `summarize()` function, on the other hand, *is* destructive. It collapses our dataset into a single value and throws away any columns that we don't use when summarizing.\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/grp-summarize-00.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\nAfter using `summarize()` on the penguins data, we only see three values in one row: average bill length, total penguin weight, and the number of penguins in the dataset. All other columns are gone.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  summarize(\n    avg_bill_length = mean(bill_length_mm),\n    total_weight = sum(body_mass_g),\n    n_penguins = n()  # This returns the number of rows in the dataset\n  )\n## # A tibble: 1 × 3\n##   avg_bill_length total_weight n_penguins\n##             <dbl>        <int>      <int>\n## 1            44.0      1400950        333\n```\n:::\n\n\n\n\n# Grouping and ungrouping with `group_by()` and `ungroup()`\n\nThe `group_by()` function splits a dataset into smaller subsets based on the values of columns that we specify. Importantly, this splitting happens ***behind the scenes***—you don't actually ever see the data split up into smaller datasets.^[I like to imagine that the data is splitting into smaller groups, [Minority Report](https://www.youtube.com/watch?v=NwVBzx0LMNQ)-style, or like [Tony Stark's JARVIS-enabled HUD](https://www.youtube.com/watch?v=E7-o6a0OUHY).] To undo the grouping and bring all the rows back together, use `ungroup()`.\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/grp-ungroup.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\nImportantly, grouping doesn't actually change the order of the rows in the dataset. If we use `group_by()` and look at your dataset, it'll still be in the existing order. The only sign that the data is invisibly grouped is a little `Groups: sex [2]` note at the top of the output.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(sex)\n## # A tibble: 333 × 8\n## # Groups:   sex [2]\n##    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex     year\n##    <fct>   <fct>              <dbl>         <dbl>             <int>       <int> <fct>  <int>\n##  1 Adelie  Torgersen           39.1          18.7               181        3750 male    2007\n##  2 Adelie  Torgersen           39.5          17.4               186        3800 female  2007\n##  3 Adelie  Torgersen           40.3          18                 195        3250 female  2007\n##  4 Adelie  Torgersen           36.7          19.3               193        3450 female  2007\n##  5 Adelie  Torgersen           39.3          20.6               190        3650 male    2007\n##  6 Adelie  Torgersen           38.9          17.8               181        3625 female  2007\n##  7 Adelie  Torgersen           39.2          19.6               195        4675 male    2007\n##  8 Adelie  Torgersen           41.1          17.6               182        3200 female  2007\n##  9 Adelie  Torgersen           38.6          21.2               191        3800 male    2007\n## 10 Adelie  Torgersen           34.6          21.1               198        4400 male    2007\n## # ℹ 323 more rows\n```\n:::\n\n\n\nGrouping is fairly useless on its own, but it becomes really powerful when combined with `mutate()` or `summarize()`.\n\n\n# Mutating within groups\n\nIf we use `mutate()` after grouping, new columns are added to each subset separately. In many cases, you won't notice any difference between using `mutate()` on an ungrouped or grouped dataset—you'll get the same values. For instance, if we use `mutate(body_mass_kg = body_mass_g / 1000)` on an ungrouped dataset, R will create a column for the whole dataset that divides `body_mass_g` by 1,000; if we use `mutate(body_mass_kg = body_mass_g / 1000)` on a *grouped* dataset, R will create a new column *within each of the subsets*. Both approaches will generate the same values.^[Using `mutate()` on the grouped dataset will be a tiiiiiny bit slower because it's actually running `mutate()` on each of the groups.]\n\nThis is actually important if we're referencing other values within the group. In the example above, we created a new column `y` that subtracted the smallest value of `x` from each value of `x`. When running `mutate(y = x - min(x))` on the ungrouped dataset, the smallest value of `x` is 1, so all the numbers decrease by 1. When running `mutate(y = x * 2)` on a *grouped* dataset, though, `min(x)` refers to the smallest value of `x` *within each of the subsets*. Check out this example here: the minimum values in groups A, B, and C are 1, 4, and 7 respectively, so in subset A we subtract 1 from all the values of `x`, in subset B we subtract 4 from all the values of `x`, and in subset C we subtract 7 from all the values of `x`. As a result, the new `y` column contains 0, 1, and 2 in each of the groups:\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/grp-mutate.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\nPanel data (or time-series cross-sectional data, like the gapminder dataset) is good example of a situation where grouping and mutating is important. For example, we can use `lag()` to create a new column (`lifeExp_previous`) that shows the previous year's life expectancy.^[This is super common with models where you time-shifted variables, like predicting an outcome based on covariates in the previous year.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(gapminder)\n\ngapminder_smaller <- gapminder |> \n  filter(year %in% c(1997, 2002, 2007))  # Only show a few years\n  \ngapminder_smaller |> \n  mutate(lifeExp_previous = lag(lifeExp), .after = lifeExp)\n## # A tibble: 426 × 7\n##    country     continent  year lifeExp lifeExp_previous      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>            <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1997    41.8             NA   22227415      635.\n##  2 Afghanistan Asia       2002    42.1             41.8 25268405      727.\n##  3 Afghanistan Asia       2007    43.8             42.1 31889923      975.\n##  4 Albania     Europe     1997    73.0             43.8  3428038     3193.\n##  5 Albania     Europe     2002    75.7             73.0  3508512     4604.\n##  6 Albania     Europe     2007    76.4             75.7  3600523     5937.\n##  7 Algeria     Africa     1997    69.2             76.4 29072015     4797.\n##  8 Algeria     Africa     2002    71.0             69.2 31287142     5288.\n##  9 Algeria     Africa     2007    72.3             71.0 33333216     6223.\n## 10 Angola      Africa     1997    41.0             72.3  9875024     2277.\n## # ℹ 416 more rows\n```\n:::\n\n\n\nAfghanistan in 1997 has a lagged life expectancy of `NA`, but that's fine and to be expected—there's no row for it to look at and copy the value (i.e. there's no Afghanistan 1992 row). Afghanistan's lagged life expectancy in 2002 is the same value as the actual life expectancy in 1997. Great, it worked!^[Technically this isn't a one-year lag; this is a five-year lag, since the data is spaced every 5 years.]\n\nBut look at Albania's lagged life expectancy in 1997—it's 43.84, which is actually Afghanistan's 2007 life expectancy! Lagged values bleed across countries here.\n\nIf we group the data by country before lagging, though, the lagging happens *within each of the subsets*, so the first year of every country is missing (since there's no previous year to look at). Now every country's 1997 value is `NA`, since the new column was created separately in each of the smaller behind-the-scenes country-specific datasets:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder_smaller |> \n  group_by(country) |> \n  mutate(lifeExp_previous = lag(lifeExp), .after = lifeExp)\n## # A tibble: 426 × 7\n## # Groups:   country [142]\n##    country     continent  year lifeExp lifeExp_previous      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>            <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1997    41.8             NA   22227415      635.\n##  2 Afghanistan Asia       2002    42.1             41.8 25268405      727.\n##  3 Afghanistan Asia       2007    43.8             42.1 31889923      975.\n##  4 Albania     Europe     1997    73.0             NA    3428038     3193.\n##  5 Albania     Europe     2002    75.7             73.0  3508512     4604.\n##  6 Albania     Europe     2007    76.4             75.7  3600523     5937.\n##  7 Algeria     Africa     1997    69.2             NA   29072015     4797.\n##  8 Algeria     Africa     2002    71.0             69.2 31287142     5288.\n##  9 Algeria     Africa     2007    72.3             71.0 33333216     6223.\n## 10 Angola      Africa     1997    41.0             NA    9875024     2277.\n## # ℹ 416 more rows\n```\n:::\n\n\n\n\n# Summarizing groups with `group_by() |> summarize()`\n\nWhile collapsing an entire dataset can be helpful for finding overall summary statistics (e.g. the average, minimum, and maximum values for columns you're interested in), `summarize()` is better used with groups. If we use `summarize()` on a *grouped* dataset, *each subset is collapsed into a single row*. This will create different summary values, depending on the groups you use. In this example, grouping by `cat1` gives us a summarized dataset with three rows (for `a`, `b`, and `c`):\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/grp-summarize-01.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\nWhile here, if we group by `cat2`, we get a summarized dataset with two rows (for `j` and `k`):\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/grp-summarize-02.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\nIf we use `group_by()` before summarizing the penguins data, we'll get a column for the group, along with average bill length, total penguin weight, and the number of penguins *in each group*. As before, all other columns are gone.\n\nWe can see summarized values by species:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species) |> \n  summarize(\n    avg_bill_length = mean(bill_length_mm),\n    total_weight = sum(body_mass_g),\n    n_penguins = n()  # This returns the number of rows in each group\n  )\n## # A tibble: 3 × 4\n##   species   avg_bill_length total_weight n_penguins\n##   <fct>               <dbl>        <int>      <int>\n## 1 Adelie               38.8       541100        146\n## 2 Chinstrap            48.8       253850         68\n## 3 Gentoo               47.6       606000        119\n```\n:::\n\n\n\n…or by sex…\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(sex) |> \n  summarize(\n    avg_bill_length = mean(bill_length_mm),\n    total_weight = sum(body_mass_g),\n    n_penguins = n()\n  )\n## # A tibble: 2 × 4\n##   sex    avg_bill_length total_weight n_penguins\n##   <fct>            <dbl>        <int>      <int>\n## 1 female            42.1       637275        165\n## 2 male              45.9       763675        168\n```\n:::\n\n\n\n…or by any other column.\n\n::: {.callout-caution}\n### Grouping by numeric columns\n\nOne common mistake is to feed a numeric columns into `group_by()`, like this:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(flipper_length_mm) |> \n  summarize(\n    avg_bill_length = mean(bill_length_mm),\n    total_weight = sum(body_mass_g),\n    n_penguins = n()\n  )\n## # A tibble: 54 × 4\n##    flipper_length_mm avg_bill_length total_weight n_penguins\n##                <int>           <dbl>        <int>      <int>\n##  1               172            37.9         3150          1\n##  2               174            37.8         3400          1\n##  3               176            40.2         3450          1\n##  4               178            39.0        13300          4\n##  5               180            39.8        14900          4\n##  6               181            41.5        24000          7\n##  7               182            39.6         9775          3\n##  8               183            39.2         6625          2\n##  9               184            37.9        25650          7\n## 10               185            38.0        31550          9\n## # ℹ 44 more rows\n```\n:::\n\n\n\nThis technically calculates *something*, but it's generally not what you're looking for. R is making groups for each of the unique values of flipper length and then calculating summaries for those groups. There's only one penguin with a flipper length of 172 mm; there are 7 with 181 mm. Grouping by a numeric variable can be useful if you want to create a histogram-like table of counts of unique values, but most of the time, you don't want to do this.\n\n:::\n\n\n# Summarizing multiple groups\n\nWe can specify more than one group with `group_by()`, which will create behind-the-scenes datasets for each unique combination of values in the groups. Here, when group by both `cat1` and `cat2`, we get six groups (`a & j`, `a & k`, `b & j`, `b & k`, `c & j`, `c & k`), which we can then use with `mutate()` or `summarize()`:\n\n::: {.column-page-inset-right}\n\n\n```{=html}\n<video controls width=\"100%\" style=\"display: block; margin: auto;\">\n  <source src=\"downloads/Video/grp-summarize-03.mp4\" type=\"video/mp4\">\n</video>\n```\n\n\n:::\n\n\\ \n\n\n# Leftover groupings and `ungroup()`\n\nSome subtle and interesting things happen when summarizing with multiple groups, though, and they throw people off all the time.\n\nWhen you use `summarize()` on a grouped dataset, **{dplyr} will automatically ungroup the last of the groups**. This happens invisibly when you're only grouping by one thing. For example, this has three rows, and no `Groups: species[3]` note at the top:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species) |> \n  summarize(total = n())\n## # A tibble: 3 × 2\n##   species   total\n##   <fct>     <int>\n## 1 Adelie      146\n## 2 Chinstrap    68\n## 3 Gentoo      119\n```\n:::\n\n\n\nWhen grouping by multiple things, {dplyr} will automatically ungroup the last of the groups (i.e. the right-most group), but keep everything else grouped. This has six rows and is grouped by species (hence the `Groups: species [3]`), and R gives you an extra message alerting you to the fact that it's still grouped by something: `` `summarise()` has grouped output by 'species'.``\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species, sex) |> \n  summarize(total = n())\n## `summarise()` has grouped output by 'species'. You can override using the `.groups` argument.\n## # A tibble: 6 × 3\n## # Groups:   species [3]\n##   species   sex    total\n##   <fct>     <fct>  <int>\n## 1 Adelie    female    73\n## 2 Adelie    male      73\n## 3 Chinstrap female    34\n## 4 Chinstrap male      34\n## 5 Gentoo    female    58\n## 6 Gentoo    male      61\n```\n:::\n\n\n\nThe same thing happens in reverse if we switch species and sex. The results here are still grouped by sex:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(sex, species) |> \n  summarize(total = n())\n## `summarise()` has grouped output by 'sex'. You can override using the `.groups` argument.\n## # A tibble: 6 × 3\n## # Groups:   sex [2]\n##   sex    species   total\n##   <fct>  <fct>     <int>\n## 1 female Adelie       73\n## 2 female Chinstrap    34\n## 3 female Gentoo       58\n## 4 male   Adelie       73\n## 5 male   Chinstrap    34\n## 6 male   Gentoo       61\n```\n:::\n\n\n\nWe can use `ungroup()` to bring the data all the way back together and get rid of the groups:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species, sex) |> \n  summarize(total = n()) |> \n  ungroup()\n## `summarise()` has grouped output by 'species'. You can override using the `.groups` argument.\n## # A tibble: 6 × 3\n##   species   sex    total\n##   <fct>     <fct>  <int>\n## 1 Adelie    female    73\n## 2 Adelie    male      73\n## 3 Chinstrap female    34\n## 4 Chinstrap male      34\n## 5 Gentoo    female    58\n## 6 Gentoo    male      61\n```\n:::\n\n\n\nAlternatively, `summarize` has a `.groups` argument that you can use to control what happens to the groups after you summarize. By default, it uses `.groups = \"drop_last\"` and gets rid of the right-most group, but you can also drop all the groups (`.groups = \"drop\"`) and keep all the groups (`.groups = \"keep\"`). See? No groups!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species, sex) |> \n  summarize(total = n(), .groups = \"drop\")\n## # A tibble: 6 × 3\n##   species   sex    total\n##   <fct>     <fct>  <int>\n## 1 Adelie    female    73\n## 2 Adelie    male      73\n## 3 Chinstrap female    34\n## 4 Chinstrap male      34\n## 5 Gentoo    female    58\n## 6 Gentoo    male      61\n```\n:::\n\n\n\n::: {.callout-tip}\n## Experimental different way of grouping and summarizing\n\nWith newer versions of {dplyr} there's a new experimental way to specify groups when summarizing, borrowed from [{data.table}](https://rdatatable.gitlab.io/data.table/). Rather than specify groups in an explicit `group_by()` function, you can do it inside `summarize()` with the `.by` argument:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  summarize(total = n(), .by = c(species, sex))\n## # A tibble: 6 × 3\n##   species   sex    total\n##   <fct>     <fct>  <int>\n## 1 Adelie    male      73\n## 2 Adelie    female    73\n## 3 Gentoo    female    58\n## 4 Gentoo    male      61\n## 5 Chinstrap female    34\n## 6 Chinstrap male      34\n```\n:::\n\n\n\nThis automatically ungroups everything when it's done, so you don't have any leftover groupings.\n\n:::\n\n\n# Why care about leftover groups?\n\nLots of the time, you don't actually need to worry about leftover groupings. If you're plotting or modeling or doing other stuff with the data, those functions will ignore the groups and work on the whole dataset. For example, I do stuff like calculating and plotting group summaries all the time—`plot_data` here is still grouped by `species` after summarizing, but `ggplot()` doesn't care:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_data <- penguins |> \n  group_by(species, sex) |> \n  summarize(total = n())\n## `summarise()` has grouped output by 'species'. You can override using the `.groups` argument.\n\n# plot_data is grouped by sex, but that doesn't matter here\nggplot(plot_data, aes(x = species, y = total, fill = species)) +\n  geom_col() + \n  guides(fill = \"none\") +\n  facet_wrap(vars(sex))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-grouped-data-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nLeftover groups are ***very important*** when you use things like `mutate()` on the summarized dataset.\n\nLike here, we'll create a proportion column based on `total / sum(total)`. Because we only grouped by one thing, there are no leftover groupings, so the `prop` column adds up to 100%:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species) |> \n  summarize(total = n()) |> \n  mutate(prop = total / sum(total))\n## # A tibble: 3 × 3\n##   species   total  prop\n##   <fct>     <int> <dbl>\n## 1 Adelie      146 0.438\n## 2 Chinstrap    68 0.204\n## 3 Gentoo      119 0.357\n```\n:::\n\n\n\nNext, we'll group by two things, which creates behind-the-scenes datasets for all the six combinations of species and sex. When {dplyr} is done, it ungroups the sex group, but leaves the dataset grouped by species. The `prop` column no longer adds up to 100%; it adds to 300%. That's because it calculated `total/sum(total)` *within* each species group (so 50% of Adélies are female, 50% are male, etc.)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species, sex) |> \n  summarize(total = n()) |> \n  mutate(prop = total / sum(total))\n## `summarise()` has grouped output by 'species'. You can override using the `.groups` argument.\n## # A tibble: 6 × 4\n## # Groups:   species [3]\n##   species   sex    total  prop\n##   <fct>     <fct>  <int> <dbl>\n## 1 Adelie    female    73 0.5  \n## 2 Adelie    male      73 0.5  \n## 3 Chinstrap female    34 0.5  \n## 4 Chinstrap male      34 0.5  \n## 5 Gentoo    female    58 0.487\n## 6 Gentoo    male      61 0.513\n```\n:::\n\n\n\nIf we reverse the grouping order so that sex comes first, {dplyr} will automatically stop grouping by species and keep the dataset grouped by sex. That means `mutate()` will work *within* each sex group, so the `prop` column here adds to 200%. 44% of female penguins are Adélies, 21% of female penguins are Chinstraps, and 35% of female penguins are Gentoos, and so on.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(sex, species) |> \n  summarize(total = n()) |> \n  mutate(prop = total / sum(total))\n## `summarise()` has grouped output by 'sex'. You can override using the `.groups` argument.\n## # A tibble: 6 × 4\n## # Groups:   sex [2]\n##   sex    species   total  prop\n##   <fct>  <fct>     <int> <dbl>\n## 1 female Adelie       73 0.442\n## 2 female Chinstrap    34 0.206\n## 3 female Gentoo       58 0.352\n## 4 male   Adelie       73 0.435\n## 5 male   Chinstrap    34 0.202\n## 6 male   Gentoo       61 0.363\n```\n:::\n\n\n\nIf we explicitly ungroup before calculating the proportion,^[Or use the `.groups` argument or `.by` argument in `summarize()`] then `mutate()` will work on the whole dataset instead of sex- or species-specific groups. Here, 22% of all penguins are female Adélies, 10% are female Chinstraps, etc.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(sex, species) |> \n  summarize(total = n()) |> \n  ungroup() |> \n  mutate(prop = total / sum(total))\n## `summarise()` has grouped output by 'sex'. You can override using the `.groups` argument.\n## # A tibble: 6 × 4\n##   sex    species   total  prop\n##   <fct>  <fct>     <int> <dbl>\n## 1 female Adelie       73 0.219\n## 2 female Chinstrap    34 0.102\n## 3 female Gentoo       58 0.174\n## 4 male   Adelie       73 0.219\n## 5 male   Chinstrap    34 0.102\n## 6 male   Gentoo       61 0.183\n```\n:::\n\n\n\nWe don't have to rely on {dplyr}'s automatic ungroup-the-last-grouping feature and we can add our own grouping explicitly later. Like here, {dplyr} stops grouping by sex, which means that the `prop` column would add to 300%, showing the proportion of sexes within each species. But if we throw in a `group_by(sex)` before `mutate()`, it'll put everything in two behind-the-scenes datasets (male and female) and calculate the proportion of species within each sex. The resulting dataset is still grouped by sex, since `mutate()` doesn't drop any groups like `summarize()`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species, sex) |> \n  summarize(total = n()) |> \n  group_by(sex) |>\n  mutate(prop = total / sum(total))\n## `summarise()` has grouped output by 'species'. You can override using the `.groups` argument.\n## # A tibble: 6 × 4\n## # Groups:   sex [2]\n##   species   sex    total  prop\n##   <fct>     <fct>  <int> <dbl>\n## 1 Adelie    female    73 0.442\n## 2 Adelie    male      73 0.435\n## 3 Chinstrap female    34 0.206\n## 4 Chinstrap male      34 0.202\n## 5 Gentoo    female    58 0.352\n## 6 Gentoo    male      61 0.363\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}