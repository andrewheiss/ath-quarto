{
  "hash": "77c8ac9e033fc892b36541e59ac8ce2b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Calculating birthday probabilities with R instead of math\"\ndate: 2024-05-03\ndescription: \"Probability math is hard. Use brute force simulation to find the probability that a household has a cluster of birthdays.\"\nimage: \"index_files/figure-html/plot-heiss-birthday-cycle-1.png\"\ntwitter-card:\n  image: \"index_files/figure-html/plot-heiss-birthday-cycle-1.png\"\nopen-graph:\n  image: \"index_files/figure-html/plot-heiss-birthday-cycle-1.png\"\ncategories:\n  - r\n  - tidyverse\n  - simulations\n  - probability\nformat:\n  html: \n    shift-heading-level-by: 1\n    include-in-header:\n      - text: |\n          <style type=\"text/css\">\n          hr.dinkus {\n              width: 50px;\n              margin: 2em auto 2em;\n              border-top: 5px dotted #454545;\n          }\n          \n          div.column-margin+hr.dinkus {\n              margin: 1em auto 2em;\n          }\n          </style>\ndoi: 10.59350/r419r-zqj73\ncitation: true\n---\n\n\n\n\n\n\n\n\n\nEven though I've been teaching R and statistical programming since 2017, and despite the fact that I do all sorts of heavily quantitative research, *I'm really really bad at probability math*.\n\nLike super bad.\n\nThe last time I truly had to do set theory and probability math was in my first PhD-level stats class in 2012. The professor cancelled classes after the first month and gave us all of October to re-teach ourselves calculus and probability theory (thank you [Sal Khan](https://www.khanacademy.org/)), and then the rest of the class was pretty much all about pure set theory stuff. It was… not fun.\n\nBut I learned a valuable secret power from the class. During the final couple weeks of the course, the professor mentioned in passing that it's possible to skip most of this probability math and instead use simulations to get the same answers. That one throwaway comment changed my whole approach to doing anything based on probabilities.\n\n\n# Why simulate?\n\nIn one problem set from November 2012^[I wrote this in a `.Rnw` file! R Markdown wasn't even a thing yet!], we had to answer this question using both actual probability math and R simulation:\n\n> An urn contains 10 red balls, 10 blue balls, and 20 green balls. If 5 balls are selected at random without replacement, what is the probability that at least 1 ball of each color will be selected?\n\n## ew probability math\n\nWe can find this probability by finding the probability of *not* selecting one or more of the colors in the draw and subtracting it from 1. We need to find the probability of selecting no red balls, no blue balls, and no green balls, and then subtract the probability of the overlapping situations (i.e. no red or blue balls, no red or green balls, and no blue or green balls).\n\nTo do this, we can use *n*-choose-*k* notation from combinatorics to represent the number of choices from a pool of possible combinations. This notation looks like this:\n\n$$\n\\dbinom{n}{k} = \\frac{n!}{k! (n-k)!}\n$$\n\nIf we're selecting 5 balls from a pool of 40, we can say \"40 choose 5\", or $\\binom{40}{5}$. To calculate that, we get this gross mess:\n\n$$\n\\begin{aligned}\n\\dbinom{40}{5} &= \\frac{40!}{5! (40-5)!} \\\\[10pt]\n&= \\frac{40!}{5!\\ 35!} \\\\[10pt]\n&= \\frac{40 \\times 39 \\times 38 \\times 37 \\times 36}{5!} \\qquad \\text{(cancel out the 35!)} \\\\[10pt]\n&= \\frac{78,960,960}{120} \\\\[10pt]\n&= 658,008\n\\end{aligned}\n$$\n\nOr we can do it with R:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchoose(40, 5)\n## [1] 658008\n```\n:::\n\n\n\nSo with this binomial choose notation, we can calculate the official formal probability of drawing at least one red, blue, and green ball from this urn:\n\n::: {.column-screen-inset}\n\n$$\n\\begin{aligned}\n\\text{Pr}(\\text{at least one red, blue, and green}) &= 1 - \\frac{\\text{Ways to get no red or no blue or no green}}{\\text{Ways to get 5 balls from 40}} \\\\[10pt]\n&= 1 - \\dfrac{\n    \\begin{array}{@{}c@{}}\n        (\\text{Ways to get no red}) + (\\text{Ways to get no blue}) + (\\text{Ways to get no green}) - \\\\\n        (\\text{Ways to get no red or blue}) - (\\text{Ways to get no red or green}) - (\\text{Ways to get no blue or green})\n    \\end{array}\n  }{\\text{Ways to get 5 balls from 40}} \\\\[10pt]\n&= 1 - \\dfrac{\n    \\dbinom{30}{5} + \\dbinom{30}{5} + \\dbinom{20}{5} - \\dbinom{20}{5} - \\dbinom{10}{5} - \\dbinom{10}{5}\n  }{\n    \\dbinom{40}{5}\n}\n\\end{aligned}\n$$\n\n:::\n\nIf we *really* really wanted, we could then calculate all of that by hand, but ew.\n\nWe can just use R instead:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Ways to draw 5 balls without getting a specific color\nno_red <- choose(30, 5)\nno_blue <- choose(30, 5)\nno_green <- choose(20, 5)\n\n# Ways to draw 5 balls without getting two specific colors\nno_red_blue <- choose(20, 5)\nno_red_green <- choose(10, 5)\nno_blue_green <- choose(10, 5)\n\n# Ways to draw 5 balls in general\ntotal_ways <- choose(40, 5)\n\n# Probability of drawing at least 1 of each color\nprob_real <- 1 - (no_red + no_blue + no_green - no_red_blue - no_red_green - no_blue_green) / total_ways\nprob_real\n## [1] 0.5676\n```\n:::\n\n\n\nGreat. There's a 56.76% chance of drawing at least one of each color. We have an answer, but this was really hard, and I could only do it because I dug up my old problem sets from 2012.\n\n## yay brute force simulation\n\nI really don't like formal probability math. Fortunately there's a way I find a heck of a lot easier to use. Brute force simulation. \n\nInstead of figuring out all these weird *n*-choose-*k* probabilities, we'll use the power of computers to literally draw from a hypothetical urn over and over and over again until we come to the right answer.\n\nHere's one way to do it:^[Again, this is 2012-era R code; nowadays I'd forgo the loop and use something like `purrr::map()` or `sapply()`.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Make this randomness consistent\nset.seed(12345)\n\n# Make an urn with balls in it\nurn <- c(rep('red', 10), rep('blue', 10), rep('green', 20))\n\n# How many times we'll draw from the urn\nsimulations <- 100000\n\ncount <- 0\nfor (i in 1:simulations) {\n  # Pick 5 balls from the urn\n  draw <- sample(urn, 5)\n  \n  # See if there's a red, blue, and green; if so, record it\n  if ('red' %in% draw && 'blue' %in% draw && 'green' %in% draw) {\n    count <- count + 1\n  }\n}\n\n# Find the simulated probability\nprob_simulated <- count / simulations\nprob_simulated\n## [1] 0.5681\n```\n:::\n\n\n\nSweet. The simulation spat out 0.5681, which is shockingly close to 0.5676. If we boosted the number of simulations from 100,000 to something even higher,^[Going up to 2,000,000 got me to 0.5676.] we'd eventually converge on the true answer.\n\n\n\n```{=html}\n<hr class=\"dinkus\">\n```\n\n\n\nI use this simulation-based approach to anything mathy as much as I can. Personally, I find it far more intuitive to re-create the data generating process rather than think in set theory and combinatorics. In my program evaluation class, we do an [in-class activity with the dice game Zilch](https://evalsp24.classes.andrewheiss.com/resource/zilch.html) where we figure out the probability of scoring something in a given dice roll. Instead of finding real probabilities, we just simulate thousands of dice rolls and mark if something was rolled. We essentially recreate the exact data generating process.\n\nThis approach is also the core of modern Bayesian statistics. Calculating complex integrals to find posterior distributions is too hard, so we can use Markov Chain Monte Carlo (MCMC) processes bounce around the plausible space for a posterior distribution until they settle on a stable value.\n\n\n# Birthday probabilities\n\nA couple days ago, I came across [this post on Bluesky](https://bsky.app/profile/karlrohe.bsky.social/post/3krgobe22kt2k):\n\n![Post by Karl Rohe (\\@karlrohe.bsky.social)](karl-rohe-skeet.png){width=80%}\n\nThis is neat because it's also the case in my household. We have \"birthday season\" from May to November, and have a dearth of birthdays from November to May. They're all clustered in half the year. I'd never thought about how unlikely that was.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-heiss-birthday-cycle-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\nThere's probably some formal probability math that can answer Karl's question precisely, but that's hard. So instead, I decided to figure this out with my old friend—brute force simulation.\n\nThe data generating process is a little more complicated than just drawing balls from urns, and the cyclical nature of calendars adds an extra wrinkle to simulating everything, but it's doable (and fun!), so I figured I'd share the details of the simulation process here. And with the recent release of [{ggplot2} 3.5](https://www.tidyverse.org/blog/2024/02/ggplot2-3-5-0/) and its [new `coord_radial()`](https://www.tidyverse.org/blog/2024/03/ggplot2-3-5-0-coord-radial/) and [legend placement settings](https://www.tidyverse.org/blog/2024/02/ggplot2-3-5-0-legends/#placement) and [point-based text sizing](https://www.tidyverse.org/blog/2024/02/ggplot2-3-5-0-legends/#placement) and [absolute plot-based positioning](https://www.tidyverse.org/blog/2024/02/ggplot2-3-5-0/#ignoring-scales), I figured I'd make some pretty plots along the way.\n\nLet's load some libraries, make a custom theme, and get started!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(patchwork)\n\nclrs <- MetBrewer::met.brewer(\"Demuth\")\n\n# Custom ggplot theme to make pretty plots\n# Get the font at https://fonts.google.com/specimen/Montserrat\ntheme_calendar <- function() {\n  theme_minimal(base_family = \"Montserrat\") +\n    theme(\n      axis.text.y = element_blank(),\n      axis.title = element_blank(),\n      panel.grid.minor = element_blank(),\n      plot.title = element_text(face = \"bold\", hjust = 0.5),\n      plot.subtitle = element_text(hjust = 0.5)\n    )\n}\n\nupdate_geom_defaults(\"text\", list(family = \"Montserrat\"))\n```\n:::\n\n\n\n# Visualizing birthday distributions and spans\n\n## All birthdays within 6-month span\n\nFirst, let's work with a hypothetical household with four people in it with birthdays on January 4, March 10, April 28, and May 21. We'll plot these on a radial plot and add a 6-month span starting at the first birthday:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# All these happen within a 6-month span\nbirthdays_yes <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-05-21\")\n)\n\ntibble(x = birthdays_yes) |> \n  ggplot(aes(x = x, y = \"\")) +\n  annotate(\n    geom = \"segment\", \n    x = birthdays_yes[1], xend = birthdays_yes[1] + months(6), y = \"\",\n    linewidth = 3, color = clrs[5]) +\n  geom_point(size = 5, fill = clrs[10], color = \"white\", pch = 21) +\n  annotate(\n    \"text\", \n    label = \"Yep\", fontface = \"bold\",\n    x = I(0.5), y = I(0),\n    size = 14, size.unit = \"pt\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\", date_labels = \"%B\",\n    limits = c(ymd(\"2024-01-01\"), ymd(\"2024-12-31\")),\n    expand = expansion(0, 0)\n  ) +\n  scale_y_discrete(expand = expansion(add = c(0, 1))) +\n  coord_radial(inner.radius = 0.8) +\n  theme_calendar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-yes-easy-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nThe four birthdays all fit comfortably within the 6-month span. Neat.\n\n## All birthdays within 6-month span, but tricky\n\nNext, let's change the May birthday to December 1. These four birthdays still all fit within a 6-month span, but it's trickier to see because the calendar year resets in the middle. Earlier, we plotted the yellow span with `annotate()`, but if we do that now, it breaks and we get a warning. We can't draw a line segment from December 1 to six months later:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_yes_but_tricky <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-12-01\")\n)\n\ntibble(x = birthdays_yes_but_tricky) |> \n  ggplot(aes(x = x, y = \"\")) +\n  annotate(\n    geom = \"segment\",\n    x = birthdays_yes_but_tricky[4],\n    xend = birthdays_yes_but_tricky[4] + months(6),\n    y = \"\",\n    linewidth = 3, color = clrs[5]) +\n  geom_point(size = 5, fill = clrs[10], color = \"white\", pch = 21) +\n  annotate(\n    \"text\", \n    label = \"Yep\\n(but broken)\", fontface = \"bold\",\n    x = I(0.5), y = I(0),\n    size = 14, size.unit = \"pt\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\", date_labels = \"%B\",\n    limits = c(ymd(\"2024-01-01\"), ymd(\"2024-12-31\")),\n    expand = expansion(0, 0)\n  ) +\n  scale_y_discrete(expand = expansion(add = c(0, 1))) +\n  coord_radial(inner.radius = 0.8) +\n  theme_calendar()\n## Warning: Removed 1 row containing missing values or values outside the scale range (`geom_segment()`).\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-yes-tricky-annotate-no-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nInstead, we can draw two line segments—one from December 1 to December 31, and one from January 1 to whatever six months from December 1 is. Since this plot represents all of 2024, we'll force the continued time after January 1 to also be in 2024 (even though it's technically 2025). Here I colored the segments a little differently to highlight the fact that they're two separate lines:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntibble(x = birthdays_yes_but_tricky) |> \n  ggplot(aes(x = x, y = \"\")) +\n  annotate(\n    geom = \"segment\",\n    x = birthdays_yes_but_tricky[4], \n    xend = ymd(\"2024-12-31\"), \n    y = \"\",\n    linewidth = 3, color = clrs[5]) +\n  annotate(\n    geom = \"segment\",\n    x = ymd(\"2024-01-01\"), \n    xend = (ymd(\"2024-01-01\") + months(6)) - \n      (ymd(\"2024-12-31\") - birthdays_yes_but_tricky[4]), \n    y = \"\",\n    linewidth = 3, color = clrs[4]) +\n  geom_point(size = 5, fill = clrs[10], color = \"white\", pch = 21) +\n  annotate(\n    \"text\", \n    label = \"Yep\\n(but tricky)\", fontface = \"bold\",\n    x = I(0.5), y = I(0),\n    size = 14, size.unit = \"pt\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\", date_labels = \"%B\",\n    limits = c(ymd(\"2024-01-01\"), ymd(\"2024-12-31\")),\n    expand = expansion(0, 0)\n  ) +\n  scale_y_discrete(expand = expansion(add = c(0, 1))) +\n  coord_radial(inner.radius = 0.8) +\n  theme_calendar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-yes-tricky-annotate-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nWriting two separate `annotate()` layers feels repetitive, though, and it's easy to make mistakes. So instead, we can make a little helper function that will create a data frame with the start and end date of a six-month span. If the span crosses December 31, it returns two spans; if not, it returns one span:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncalc_date_arc <- function(start_date) {\n  days_till_end <- ymd(\"2024-12-31\") - start_date\n  \n  if (days_till_end >= months(6)) {\n    x <- start_date\n    xend <- start_date + months(6)\n  } else {\n    x <- c(start_date, ymd(\"2024-01-01\"))\n    xend <- c(\n      start_date + days_till_end, \n      (ymd(\"2024-01-01\") + months(6)) - days_till_end\n    )\n  }\n  \n  return(tibble(x = x, xend = xend))\n}\n```\n:::\n\n\n\nLet's make sure it works. Six months from March 15 is September 15, which doesn't cross into a new year, so we get just one start and end date:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncalc_date_arc(ymd(\"2024-03-15\"))\n## # A tibble: 1 × 2\n##   x          xend      \n##   <date>     <date>    \n## 1 2024-03-15 2024-09-15\n```\n:::\n\n\n\nSix months from November 15 is sometime in May, which means we *do* cross into a new year. We thus get two spans: (1) a segment from November to the end of December, and (2) a segment from January to May:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncalc_date_arc(ymd(\"2024-11-15\"))\n## # A tibble: 2 × 2\n##   x          xend      \n##   <date>     <date>    \n## 1 2024-11-15 2024-12-31\n## 2 2024-01-01 2024-05-16\n```\n:::\n\n\n\nPlotting with this function is a lot easier, since it returns a data frame. We don't need to worry about using `annotate()` anymore and can instead map the `x` and `xend` aesthetics from the data to the plot:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntibble(x = birthdays_yes_but_tricky) |> \n  ggplot(aes(x = x, y = \"\")) +\n  geom_segment(\n    data = calc_date_arc(birthdays_yes_but_tricky[4]), aes(xend = xend),\n    linewidth = 3, color = clrs[5]\n  ) +\n  geom_point(size = 5, fill = clrs[10], color = \"white\", pch = 21) +\n  annotate(\n    \"text\", \n    label = \"Yep\\n(but tricky)\", fontface = \"bold\",\n    x = I(0.5), y = I(0),\n    size = 14, size.unit = \"pt\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\", date_labels = \"%B\",\n    limits = c(ymd(\"2024-01-01\"), ymd(\"2024-12-31\")),\n    expand = expansion(0, 0)\n  ) +\n  scale_y_discrete(expand = expansion(add = c(0, 1))) +\n  coord_radial(inner.radius = 0.8) +\n  theme_calendar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-yes-tricky-good-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## Some birthdays outside a 6-month span\n\nLet's change the set of birthdays again so that one of them falls outside the six-month window. Regardless of where we start the span, we can't collect all the points within a continuous six-month period:\n\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_no <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-09-21\")\n)\n\np1 <- tibble(x = birthdays_no) |> \n  ggplot(aes(x = x, y = \"\")) +\n  geom_segment(\n    data = calc_date_arc(birthdays_no[1]), aes(xend = xend),\n    linewidth = 3, color = clrs[3]\n  ) +\n  geom_point(size = 5, fill = clrs[10], color = \"white\", pch = 21) +\n  annotate(\n    \"text\", \n    label = \"Nope\", fontface = \"bold\",\n    x = I(0.5), y = I(0),\n    size = 14, size.unit = \"pt\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\", date_labels = \"%B\",\n    limits = c(ymd(\"2024-01-01\"), ymd(\"2024-12-31\")),\n    expand = expansion(0, 0)\n  ) +\n  scale_y_discrete(expand = expansion(add = c(0, 1))) +\n  coord_radial(inner.radius = 0.8) +\n  theme_calendar()\n\np2 <- tibble(x = birthdays_no) |> \n  ggplot(aes(x = x, y = \"\")) +\n  geom_segment(\n    data = calc_date_arc(birthdays_no[4]), aes(xend = xend),\n    linewidth = 3, color = clrs[3]\n  ) +\n  geom_point(size = 5, fill = clrs[10], color = \"white\", pch = 21) +\n  annotate(\n    \"text\", \n    label = \"Still nope\", fontface = \"bold\",\n    x = I(0.5), y = I(0),\n    size = 14, size.unit = \"pt\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\", date_labels = \"%B\",\n    limits = c(ymd(\"2024-01-01\"), ymd(\"2024-12-31\")),\n    expand = expansion(0, 0)\n  ) +\n  scale_y_discrete(expand = expansion(add = c(0, 1))) +\n  coord_radial(inner.radius = 0.8) +\n  theme_calendar()\n\n(p1 | plot_spacer() | p2) + \n  plot_layout(widths = c(0.45, 0.1, 0.45))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-no-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n# Simulation time!\n\nSo far, we've been working with a hypothetical household of 4, with arbitrarily chosen birthdays. For the simulation, we'll need to work with randomly selected birthdays for households of varying sizes.\n\n## Counting simulated birthdays and measuring spans\n\nBut before we build the full simulation, we need to build a way to programmatically detect if a set of dates fit within a six-month span, which—as we saw with the plotting—is surprisingly tricky because of the possible change in year.\n\nIf we didn't need to contend with a change in year, we could convert all the birthdays to their corresponding day of the year, sort them, find the difference between the first and the last, and see if it's less than 183 days (366/2; we're working with a leap year). This would work great:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_yes <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-05-21\")\n)\n\nbirthdays_sorted <- sort(yday(birthdays_yes))\nbirthdays_sorted\n## [1]   4  70 119 142\n\nmax(birthdays_sorted) - min(birthdays_sorted)\n## [1] 138\n```\n:::\n\n\n\nBut time is a circle. If we look at a set of birthdays that crosses a new year, we can't just look at `max - min`. Also, there's no guarantee that the six-month span will go from the first to the last; it could go from the last to the first.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_yes_but_tricky <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-12-01\")\n)\n\nbirthdays_sorted <- sort(yday(birthdays_yes_but_tricky))\nbirthdays_sorted\n## [1]   4  70 119 336\n\nmax(birthdays_sorted) - min(birthdays_sorted)\n## [1] 332\n```\n:::\n\n\n\nSo we need to do something a little trickier to account for the year looping over. There are several potential ways to do this, and there's no one right way. Here's the approach I settled on.\n\nWe need to check the span between each possible window of dates. In a household of 4, this means finding the distance between the 4th (or last) date and the 1st date, which we did with `max - min`. But we also need to check on the distance between the 1st date in the next cycle (i.e. 2025) and the 2nd date (in 2024), and so on, or this:\n\n- Distance between 4th and 1st: \n  - `ymd(\"2024-12-01\") - ymd(\"2024-01-04\")` or 332 days\n- Distance between (1st + 1 year) and 2nd: \n  - `ymd(\"2025-01-04\") - ymd(\"2024-03-10\")` or 300 days\n- Distance between (2nd + 1 year) and 3rd: \n  - `ymd(\"2025-03-10\") - ymd(\"2024-04-28\")` or 316 days\n- Distance between (3rd + 1 year) and 4th: \n  - `ymd(\"2025-04-28\") - ymd(\"2024-12-01\")` or 148 days\n\nThat last one, from December 1 to April 28, is less than 180 days, which means that the dates fit within a six-month span. We saw this in the plot earlier too—if we start the span in December, it more than covers the remaining birthdays.\n\nOne easy way to look at dates in the next year is to double up the vector of birthday days-of-the-year, adding 366 to the first set, like this:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_doubled <- c(\n  sort(yday(birthdays_yes_but_tricky)), \n  sort(yday(birthdays_yes_but_tricky)) + 366\n)\n\nbirthdays_doubled\n## [1]   4  70 119 336 370 436 485 702\n```\n:::\n\n\n\nThe first four represent the regular real birthdays; the next four are the same values, just shifted up a year (so 4 and 370 are both January 1, etc.)\n\nWith this vector, we can now find differences between dates that cross years more easily:^[Some of these differences aren't the same as before (317 instead of 361; 149 instead of 148). This is because 2024 is a leap year and 2025 is not, and {lubridate} accounts for that. By adding 366, we're pretending 2025 is also a leap year. But that's okay, because we want to pretend that February 29 happens each year.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_doubled[4] - birthdays_doubled[1]\n## [1] 332\nbirthdays_doubled[5] - birthdays_doubled[2]\n## [1] 300\nbirthdays_doubled[6] - birthdays_doubled[3]\n## [1] 317\nbirthdays_doubled[7] - birthdays_doubled[4]\n## [1] 149\n```\n:::\n\n\n\nOr instead of repeating lots of lines like that, we can auto-increment the different indices:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn <- length(birthdays_yes_but_tricky)\nmap_dbl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x])\n## [1] 332 300 317 149\n```\n:::\n\n\n\nIf any of those values are less than 183, the birthdays fit in a six-month span:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nany(map_lgl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x] <= 183))\n## [1] TRUE\n```\n:::\n\n\n\nLet's check it with the other two test sets of birthdays. Here's the easy set of birthdays without any cross-year loops:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_yes <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-05-21\")\n)\n\nbirthdays_doubled <- c(\n  sort(yday(birthdays_yes)), \n  sort(yday(birthdays_yes)) + 366\n)\n\nmap_dbl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x])\n## [1] 138 300 317 343\nany(map_lgl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x] <= 183))\n## [1] TRUE\n```\n:::\n\n\n\nAnd here's the set we know doesn't fit:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirthdays_no <- c(\n  ymd(\"2024-01-04\"),\n  ymd(\"2024-03-10\"),\n  ymd(\"2024-04-28\"),\n  ymd(\"2024-09-21\")\n)\n\nbirthdays_doubled <- c(\n  sort(yday(birthdays_no)), \n  sort(yday(birthdays_no)) + 366\n)\n\nmap_dbl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x])\n## [1] 261 300 317 220\nany(map_lgl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x] <= 183))\n## [1] FALSE\n```\n:::\n\n\n\nIt works!\n\n## Actual simulation\n\nNow that we have the ability to check if any set of dates fits within six months, we can generalize this to any household size. To make life a little easier, we'll stop working with days of the year for. Leap years are tricky, and the results changed a little bit above if we added 366 or 365 to the repeated years. So instead, we'll think about 360° in a circle—circles don't suddenly have 361° every four years or anything weird like that.\n\nIn this simulation, we'll generate `n` random numbers between 0 and 360 (where `n` is the household size we're interested in). We'll then do the doubling and sorting thing and check to see if the distance between any of the 4-number spans is less than 180.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimulate_prob <- function(n, num_simulations = 1000) {\n  results <- map_lgl(1:num_simulations, ~{\n    birthdays <- runif(n, 0, 360)\n    birthdays_doubled <- sort(c(birthdays, birthdays + 360))\n    any(map_lgl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x] <= 180))\n  })\n  mean(results)\n}\n```\n:::\n\n\n\nHere's the probability of seeing all the birthdays in a six-month span in a household of 4:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  simulate_prob(4)\n})\n## [1] 0.522\n```\n:::\n\n\n\nAbout 50%!\n\nWhat about a household of 6, like in Karl's original post?\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  simulate_prob(6)\n})\n## [1] 0.189\n```\n:::\n\n\n\nAbout 18%!\n\nWe can get this more precise and consistent by boosting the number of simulations:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  simulate_prob(6, 50000)\n})\n## [1] 0.1866\n```\n:::\n\n\n\nNow that this function is working, we can use it to simulate a bunch of possible household sizes, like from 2 to 10:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimulated_households <- tibble(household_size = 2:10) |>\n  mutate(prob_in_arc = map_dbl(household_size, ~simulate_prob(.x, 10000))) |> \n  mutate(nice_prob = scales::label_percent(accuracy = 0.1)(prob_in_arc))\n\nggplot(simulated_households, aes(x = factor(household_size), y = prob_in_arc)) +\n  geom_pointrange(aes(ymin = 0, ymax = prob_in_arc), color = clrs[2]) +\n  geom_text(aes(label = nice_prob), nudge_y = 0.07, size = 8, size.unit = \"pt\") +\n  scale_y_continuous(labels = scales::label_percent()) +\n  labs(\n    x = \"Household size\",\n    y = \"Probability\",\n    title = \"Probability that all birthdays occur within \\na single six-month span across household size\",\n    caption = \"10,000 simulations\"\n  ) +\n  theme_minimal(base_family = \"Montserrat\") +\n  theme(\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    plot.caption = element_text(hjust = 0, color = \"grey50\"),\n    axis.title.x = element_text(hjust = 0),\n    axis.title.y = element_text(hjust = 1)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-household-probability-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n# But birthdays aren't uniformly distributed!\n\nWe just answered Karl's original question: \"Suppose n points are uniformly distributed on a circle. What is the probability that they belong to a connected half circle\". There's probably some official mathy combinatorial way to build a real formula to describe this pattern, but that's too hard. Simulation gets us there.\n\n## Uneven birthday disributions\n\nBut in real life, birthdays aren't actually normally distributed. There are some *fascinating* patterns in days of birth. Instead of drawing birthdays from a uniform distribution where every day is equally likely, let's draw from the actual distribution. There's no official probability-math way to do this—the only way to do this kind of calculation is with simulation.\n\nThe CDC and the Social Security Administration track the counts of daily births in the Unitd States. In 2016, [FiveThirtyEight reported a story](https://fivethirtyeight.com/features/some-people-are-too-superstitious-to-have-a-baby-on-friday-the-13th/) about patterns in daily birthrate frequencies and they [posted their CSV files on GitHub](https://github.com/fivethirtyeight/data/tree/master/births), so we'll load their data and figure out daily probabilities of birthdays.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths_1994_1999 <- read_csv(\n  \"https://raw.githubusercontent.com/fivethirtyeight/data/master/births/US_births_1994-2003_CDC_NCHS.csv\"\n) |>\n  # Ignore anything after 2000\n  filter(year < 2000)\n\nbirths_2000_2014 <- read_csv(\n  \"https://raw.githubusercontent.com/fivethirtyeight/data/master/births/US_births_2000-2014_SSA.csv\"\n)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths_combined <- bind_rows(births_1994_1999, births_2000_2014) |> \n  mutate(\n    full_date = make_date(year = 2024, month = month, day = date_of_month),\n    day_of_year = yday(full_date)\n  ) |> \n  mutate(\n    month_cateogrical = month(full_date, label = TRUE, abbr = FALSE)\n  )\nglimpse(births_combined)\n## Rows: 7,670\n## Columns: 8\n## $ year              <dbl> 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 1994, 19…\n## $ month             <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,…\n## $ date_of_month     <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n## $ day_of_week       <dbl> 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5,…\n## $ births            <dbl> 8096, 7772, 10142, 11248, 11053, 11406, 11251, 8653, 7910, 10498, 11706, 11567, 11212, 11570, 8660, 8123, 10567, 11541, 11257, 11682, 11811, 8833, 8310, 11125, 11981, 11514, 11702, 11666, 8988, 8096, 10765, 11755, 11483, 11523, 11677, 8991, 8309, 10984, 12152, 11515, 1162…\n## $ full_date         <date> 2024-01-01, 2024-01-02, 2024-01-03, 2024-01-04, 2024-01-05, 2024-01-06, 2024-01-07, 2024-01-08, 2024-01-09, 2024-01-10, 2024-01-11, 2024-01-12, 2024-01-13, 2024-01-14, 2024-01-15, 2024-01-16, 2024-01-17, 2024-01-18, 2024-01-19, 2024-01-20, 2024-01-21, 2024-01-22, 2024-01…\n## $ day_of_year       <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 7…\n## $ month_cateogrical <ord> January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, January, Ja…\n```\n:::\n\n\n\nBut first, just because this is one of my favorite graphs ever, let's visualize the data! Here's a heatmap showing the daily average births for 366 days:\n\n\n\n::: {.cell .column-body-outset layout-align=\"center\"}\n\n```{.r .cell-code}\navg_births_month_day <- births_combined |> \n  group_by(month_cateogrical, date_of_month) %>% \n  summarize(avg_births = mean(births))\n\nggplot(\n  avg_births_month_day, \n  aes(x = factor(date_of_month), y = fct_rev(month_cateogrical), fill = avg_births)\n) +\n  geom_tile() +\n  scale_fill_viridis_c(\n    option = \"rocket\", labels = scales::label_comma(),\n    guide = guide_colorbar(barwidth = 20, barheight = 0.5, position = \"bottom\")\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Average births per day\",\n    subtitle = \"1994–2014\",\n    fill = \"Average births\"\n  ) +\n  coord_equal() +\n  theme_minimal(base_family = \"Montserrat\") +\n  theme(\n    legend.justification.bottom = \"left\",\n    legend.title.position = \"top\",\n    panel.grid = element_blank(),\n    axis.title.x = element_text(hjust = 0)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-births-heatmap-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nThere are some really fascinating stories here!\n\n- Nobody wants to have babies during Christmas or New Year's. Christmas Day, Christmas Eve, and New Year's Day seem to have the lowest average births.\n- New Year's Eve, Halloween, July 4, April 1,^[No one wants joke babies?] and the whole week of Thanksgiving^[American Thanksgiving is the fourth Thursday of November, so the exact day of the month moves around each year] also have really low averages.\n- The 13th of every month has slightly fewer births than average—the column at the 13th is really obvious here.\n- The days with the highest average counts are in mid-September, from the 9th to the 20th—except for September 11.\n\nWith this data, we can calculate the daily probability of having a birthday:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprob_per_day <- births_combined |> \n  group_by(day_of_year) |> \n  summarize(total = sum(births)) |> \n  mutate(prob = total / sum(total)) |> \n  mutate(full_date = ymd(\"2024-01-01\") + days(day_of_year - 1)) |> \n  mutate(yearless_date = format(full_date, \"%B %d\"))\nglimpse(prob_per_day)\n## Rows: 366\n## Columns: 5\n## $ day_of_year   <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 7…\n## $ total         <dbl> 164362, 196481, 228259, 232354, 230826, 229776, 230233, 223766, 224116, 232521, 231414, 230499, 223803, 231343, 222374, 224055, 230038, 229465, 225387, 228138, 228190, 225098, 229163, 233021, 230897, 228394, 228012, 228365, 222831, 226669, 229472, 230364, 230984, 228433, 2298…\n## $ prob          <dbl> 0.0019176, 0.0022923, 0.0026631, 0.0027108, 0.0026930, 0.0026808, 0.0026861, 0.0026107, 0.0026147, 0.0027128, 0.0026999, 0.0026892, 0.0026111, 0.0026991, 0.0025944, 0.0026140, 0.0026838, 0.0026771, 0.0026296, 0.0026617, 0.0026623, 0.0026262, 0.0026736, 0.0027186, 0.0026938, 0…\n## $ full_date     <date> 2024-01-01, 2024-01-02, 2024-01-03, 2024-01-04, 2024-01-05, 2024-01-06, 2024-01-07, 2024-01-08, 2024-01-09, 2024-01-10, 2024-01-11, 2024-01-12, 2024-01-13, 2024-01-14, 2024-01-15, 2024-01-16, 2024-01-17, 2024-01-18, 2024-01-19, 2024-01-20, 2024-01-21, 2024-01-22, 2024-01-23,…\n## $ yearless_date <chr> \"January 01\", \"January 02\", \"January 03\", \"January 04\", \"January 05\", \"January 06\", \"January 07\", \"January 08\", \"January 09\", \"January 10\", \"January 11\", \"January 12\", \"January 13\", \"January 14\", \"January 15\", \"January 16\", \"January 17\", \"January 18\", \"January 19\", \"January 2…\n```\n:::\n\n\n\nHere are the 5 most common days:^[There's me on September 19.]\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprob_per_day |> \n  select(yearless_date, prob) |> \n  slice_max(order_by = prob, n = 5)\n## # A tibble: 5 × 2\n##   yearless_date    prob\n##   <chr>           <dbl>\n## 1 September 09  0.00302\n## 2 September 19  0.00301\n## 3 September 12  0.00301\n## 4 September 17  0.00299\n## 5 September 10  0.00299\n```\n:::\n\n\n\nAnd the 5 least probable days—Leap Day, Christmas Day, New Year's Day, Christmas Eve, and July 4th:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprob_per_day |> \n  select(yearless_date, prob) |> \n  slice_min(order_by = prob, n = 5)\n## # A tibble: 5 × 2\n##   yearless_date     prob\n##   <chr>            <dbl>\n## 1 February 29   0.000613\n## 2 December 25   0.00162 \n## 3 January 01    0.00192 \n## 4 December 24   0.00199 \n## 5 July 04       0.00216\n```\n:::\n\n\n\n## Using actual birthday probabilities\n\nInstead of drawing random numbers between 0 and 360 from a uniform distribution, we can draw day-of-the-year numbers. This is easy with `sample()`. Here's a random 4-person household:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  sample(1:366, size = 4, replace = TRUE)\n})\n## [1] 284 336 101 111\n```\n:::\n\n\n\nThat gives us a uniform probability distribution—all the numbers between 1 and 366 are equally likely. `sample()` has a `prob` argument that we can use to feed a vector of probabilities:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  sample(\n    prob_per_day$day_of_year, \n    size = 4, \n    replace = TRUE,\n    prob = prob_per_day$prob)\n})\n## [1] 284 101 111 133\n```\n:::\n\n\n\nThese days of the year now match the actual distribution of birthdays in the United States. If we simulated thousands of birthdays, we'd get more in September, fewer on the 13th of each month, and far fewer around Thanksgiving and Christmas.\n\nWe can now update our simulation to use this more realistic distribution of birthdays:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimulate_prob_real <- function(n, num_simulations = 1000) {\n  results <- map_lgl(1:num_simulations, ~{\n    birthdays <- sample(\n      prob_per_day$day_of_year, \n      size = n, \n      replace = TRUE, \n      prob = prob_per_day$prob\n    )\n    \n    birthdays_doubled <- sort(c(birthdays, birthdays + 366))\n    \n    any(map_lgl(1:n, ~ birthdays_doubled[.x + n - 1] - birthdays_doubled[.x] <= (366 / 2)))\n  })\n  mean(results)\n}\n```\n:::\n\n\n\nHere's the probability of having all the birthdays within the same six months for a household of 4:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  simulate_prob_real(4)\n})\n## [1] 0.495\n```\n:::\n\n\n\nAnd 6:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(1234, {\n  simulate_prob_real(6)\n})\n## [1] 0.202\n```\n:::\n\n\n\nAnd here's the probability across different household sizes:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsims_real <- tibble(household_size = 2:10) |>\n  mutate(prob_in_arc = map_dbl(household_size, ~simulate_prob_real(.x, 10000))) |> \n  mutate(nice_prob = scales::label_percent(accuracy = 0.1)(prob_in_arc))\n\nggplot(sims_real, aes(x = factor(household_size), y = prob_in_arc)) +\n  geom_pointrange(aes(ymin = 0, ymax = prob_in_arc), color = clrs[9]) +\n  geom_text(aes(label = nice_prob), nudge_y = 0.07, size = 8, size.unit = \"pt\") +\n  scale_y_continuous(labels = scales::label_percent()) +\n  labs(\n    x = \"Household size\",\n    y = \"Probability\",\n    title = \"Probability that all birthdays occur within a\\nsingle 6-month span across household size\",\n    subtitle = \"Based on average daily birth probabilities from 1994–2014\",\n    caption = \"10,000 simulations; daily probabilities from the CDC and SSA\"\n  ) +\n  theme_minimal(base_family = \"Montserrat\") +\n  theme(\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    plot.caption = element_text(hjust = 0, color = \"grey50\"),\n    plot.subtitle = element_text(hjust = 0, color = \"grey50\"),\n    axis.title.x = element_text(hjust = 0),\n    axis.title.y = element_text(hjust = 1)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-household-probability-real-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nIn the end, these are all roughly the same as the uniform birthday distribution, but it *feels* more accurate since the probabilities are based on real-life frequencies. \n\n\n\n```{=html}\n<hr class=\"dinkus\">\n```\n\n\n\nBut most importantly, we didn't have to do any math to get the right answer. Brute force simulation techniques got us there.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}