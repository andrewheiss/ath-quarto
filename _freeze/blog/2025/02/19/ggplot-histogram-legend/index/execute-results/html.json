{
  "hash": "50be90fe69481e770aea4f9776771241",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to use a histogram as a legend in {ggplot2}\"\ndate: 2025-02-19\ndescription: \"Land isn't unemployed—people are. Here's how to use R, {ggplot2}, {sf}, and {patchwork} to create a histogram legend in a choropleth map to better see the distribution of values.\"\n\nimage: index_files/figure-html/plot-histogram-legend-1.png\ntwitter-card: \n    image: \"index_files/figure-html/plot-histogram-legend-1.png\"\nopen-graph: \n    image: \"index_files/figure-html/plot-histogram-legend-1.png\"\n\ncategories:\n  - r\n  - tidyverse\n  - ggplot\n  - gis\n  - maps\n\nformat:\n  html:\n    shift-heading-level-by: 1\n    lightbox: true\n\ndoi: 10.59350/gt0nr-wct91\ncitation: true\n---\n\n\n\nOn Bluesky the other day, I came across [this neat post](https://bsky.app/profile/obumbratta.com/post/3lbs67ic5bc2w) that suggested using a histogram as a plot legend to provide additional context for the data being shown:\n\n![Joey Cherdarchuk's original post](img/bsky-post.png){width=\"70%\" fig-align=\"center\" .lightbox}\n\nHere's a closer comparison of those two maps (click to zoom):\n\n![Joey Cherdarchuk's maps side-by-side](img/map-histogram-legend.jpg){width=\"100%\" fig-align=\"center\" .lightbox}\n\nThis histogram legend is especially useful for choropleth maps where units like counties are sized differently, which can create an illusion of a different distribution. For instance, in that original post, larger dark blue areas stand out a lot visually—like in Alaska, New Mexico, Arizona, and Central California—and make it seem like unemployment is fairly high.\n\nBut looking at the histogram that's not actually the case. Most counties have an unemployment rate around 3–6%. This illusion is happening because [land isn't unemployed—people are](https://storymaps.arcgis.com/stories/0e636a652d44484b9457f953994b212b).\n\nI thought this was a cool approach, so I figured I'd try to replicate it with R. In the original post, [the map was created with D3, the bar chart legend was created with Excel, and the two were combined with Figma](https://bsky.app/profile/obumbratta.com/post/3lihzar4lc222). That process is a little too manual for me, but with the magic of R, {ggplot2}, and [{patchwork}](https://patchwork.data-imaginist.com/), we can create the same map completely programmatically. \n\nLet's do it!\n\n# Clean and join data\n\nFirst, let's load some packages and tweak some theme settings:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(sf)\nlibrary(tigris)\nlibrary(patchwork)\n\n# Add some font settings to theme_void()\ntheme_fancy_map <- function() {\n  theme_void(base_family = \"IBM Plex Sans\") +\n    theme(\n      plot.title = element_text(face = \"bold\", hjust = 0.13, size = rel(1.4)),\n      plot.subtitle = element_text(hjust = 0.13, size = rel(1.1)),\n      plot.caption = element_text(hjust = 0.13, size = rel(0.8), color = \"grey50\"),\n    )\n}\n```\n:::\n\n\n## BLS unemployment data\n\nNext, we can get 2016 unemployment data from the Bureau of Labor Statistics. BLS offers county-level data on annual average labor force participation [here](https://www.bls.gov/lau/tables.htm#cntyaa), both as plain text and Excel files. The plain text data is structured a little goofily (it's not comma-separated; it's a fixed width format where column headings span multiple lines), but the Excel version is in nice columns and is easier to work with. Though even then, we need to skip the first few rows, and the last few rows, and specify column names ourselves.\n\n[Download this first from the BLS](https://www.bls.gov/lau/tables.htm#cntyaa):\n\n- [Labor force data by county, 2016 annual averages (XLS)](https://www.bls.gov/lau/laucnty16.xlsx)\n\nFor the sake of mapping, we'll truncate the unemployment rate at 9% and mark any counties with higher than 9% unemployment with 9.1 and modify the legend to show \">9%\":\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load BLS data and clean it up\nbls_2016 <- read_excel(\n  \"laucnty16.xlsx\",\n  skip = 5,\n  col_names = c(\n    \"laus_code\", \"STATEFP\", \"COUNTYFP\", \"county_name_state\",\n    \"year\", \"nothing\", \"labor_force\", \"employed\", \"unemployed\", \"unemp\"\n  )\n) |> \n  # The last few rows in the Excel file aren't actually data, but extra notes,\n  # so drop those rows here since they don't have a state FIPS code\n  drop_na(STATEFP) |> \n  mutate(\n    # Truncate the unemployment rate at 9\n    unemp_truncated = ifelse(unemp > 9, 9.1, unemp),\n    # Find difference from Fed target of 4%\n    unemp_diff = unemp_truncated - 4\n  )\n\nbls_2016\n## # A tibble: 3,219 × 12\n##    laus_code       STATEFP COUNTYFP county_name_state   year  nothing labor_force employed unemployed unemp unemp_truncated unemp_diff\n##    <chr>           <chr>   <chr>    <chr>               <chr> <lgl>         <dbl>    <dbl>      <dbl> <dbl>           <dbl>      <dbl>\n##  1 CN0100100000000 01      001      Autauga County, AL  2016  NA            25710    24395       1315   5.1             5.1        1.1\n##  2 CN0100300000000 01      003      Baldwin County, AL  2016  NA            89778    84972       4806   5.4             5.4        1.4\n##  3 CN0100500000000 01      005      Barbour County, AL  2016  NA             8334     7638        696   8.4             8.4        4.4\n##  4 CN0100700000000 01      007      Bibb County, AL     2016  NA             8539     7986        553   6.5             6.5        2.5\n##  5 CN0100900000000 01      009      Blount County, AL   2016  NA            24380    23061       1319   5.4             5.4        1.4\n##  6 CN0101100000000 01      011      Bullock County, AL  2016  NA             4785     4457        328   6.9             6.9        2.9\n##  7 CN0101300000000 01      013      Butler County, AL   2016  NA             9116     8484        632   6.9             6.9        2.9\n##  8 CN0101500000000 01      015      Calhoun County, AL  2016  NA            45450    42470       2980   6.6             6.6        2.6\n##  9 CN0101700000000 01      017      Chambers County, AL 2016  NA            14858    14044        814   5.5             5.5        1.5\n## 10 CN0101900000000 01      019      Cherokee County, AL 2016  NA            11241    10671        570   5.1             5.1        1.1\n## # ℹ 3,209 more rows\n```\n:::\n\n\n## Census geographic data\n\nNext we'll get geographic data from the US Census with [{tigris}](https://github.com/walkerke/tigris)\n\n::: {.callout-note}\n#### Backup data source\n\nAt the time of this writing, {tigris} is working. It wasn't working a couple weeks ago as the wildly illegal Department of Government Efficiency rampaged through different federal agencies—including the US Census—and shut down the Census's GIS APIs. But it seems to be working for now?\n\nIf it's not working, [IPUMS's NHGIS project](https://www.nhgis.org/) offers the same shapefiles.\n:::\n\nThe BLS data and the Census data each have columns with [state and county FIPS codes](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standard_state_code) which we can use to join the two datasets:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get county and state shapefiles from Tigris\nus_counties <- counties(year = 2016, cb = TRUE) |> \n  filter(as.numeric(STATEFP) <= 56) |> \n  shift_geometry()  # Move AK and HI\n\nus_states <- states(year = 2016, cb = TRUE) |> \n  filter(as.numeric(STATEFP) <= 56) |> \n  shift_geometry()  # Move AK and HI\n\n# Join BLS data to the map\ncounties_with_unemp <- us_counties |>\n  left_join(bls_2016, by = join_by(STATEFP, COUNTYFP))\n\n# Check out the joined data\ncounties_with_unemp |> \n  select(STATEFP, COUNTYFP, county_name_state, unemp_truncated, geometry)\n## Simple feature collection with 3142 features and 4 fields\n## Geometry type: GEOMETRY\n## Dimension:     XY\n## Bounding box:  xmin: -3112000 ymin: -1698000 xmax: 2258000 ymax: 1566000\n## Projected CRS: USA_Contiguous_Albers_Equal_Area_Conic\n## First 10 features:\n##    STATEFP COUNTYFP    county_name_state unemp_truncated                       geometry\n## 1       19      107    Keokuk County, IA             4.3 MULTIPOLYGON (((297173 4548...\n## 2       19      189 Winnebago County, IA             3.4 MULTIPOLYGON (((163347 6734...\n## 3       20      093    Kearny County, KS             3.1 MULTIPOLYGON (((-482328 605...\n## 4       20      123  Mitchell County, KS             3.3 MULTIPOLYGON (((-212918 197...\n## 5       20      187   Stanton County, KS             2.8 MULTIPOLYGON (((-528445 214...\n## 6       21      005  Anderson County, KY             4.0 MULTIPOLYGON (((940067 1094...\n## 7       21      029   Bullitt County, KY             4.1 MULTIPOLYGON (((873753 1022...\n## 8       21      049     Clark County, KY             4.7 MULTIPOLYGON (((1012432 106...\n## 9       21      059   Daviess County, KY             4.4 MULTIPOLYGON (((749702 5517...\n## 10      21      063   Elliott County, KY             9.1 MULTIPOLYGON (((1102886 138...\n```\n:::\n\n\nThe map works!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = us_states, fill = \"#0074D9\", color = \"white\", linewidth = 0.25) +\n  # Albers projection\n  coord_sf(crs = st_crs(\"ESRI:102003\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-basic map-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Map adjustments\n\nWe need to make a couple little adjustments to the map first. In the original image on Bluesky, there's extra space on the right side of the map to allow for the legend. We can change the plot window by adding 10% of the width of the map to the right. \n\nTechnically we don't have to work with percents here; the data is currently using the Albers projection, which works in meters, so we could add something like 500,000 meters / 500 km to the left. But this is a more general solution and also works if the map data is in decimal degrees instead of meters.\n\nAlso, the far western Aleutian islands mess with the visual balance of the map (and they don't appear because they're so small), so we'll also subtract 10% of the map from the left.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get x-axis limits of the bounding box for the state data\nxlim_current <- st_bbox(us_states)$xlim\n\n# Add 540ish km (or 10% of the US) to the bounds (thus shifting the window over)\nxlim_expanded <- c(\n  xlim_current[1] + (0.1 * diff(xlim_current)), \n  xlim_current[2] + (0.1 * diff(xlim_current))\n)\n\nggplot() +\n  geom_sf(data = us_states, fill = \"#0074D9\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-shifted-window-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Extract interior state borders\n\nBecause we're using `color = \"white\", linewidth = 0.25`, every state gets a thin white border. This causes some issues though. All the states that share borders actually get a thicker border, since a state's western border joins up with its neighbor's eastern border. Also, all the coastlines and islands get borders, which diminishes the landmass—especially on a white background.\n\nLike, look at [Alaska's Aleutian Islands](https://en.wikipedia.org/wiki/Aleutian_Islands), or [Hawai'i's smaller islands](https://en.wikipedia.org/wiki/List_of_islands_of_Hawaii#Northwestern_Hawaii_Islands), or Michigan's [Les Cheneaux Islands](https://en.wikipedia.org/wiki/Les_Cheneaux_Islands) and [Isle Royale](https://en.wikipedia.org/wiki/Isle_Royale_National_Park), or [California's Channel Islands](https://en.wikipedia.org/wiki/Channel_Islands_(California)), or the [Florida Keys](https://en.wikipedia.org/wiki/Florida_Keys), or [North Carolina's Outer Banks](https://en.wikipedia.org/wiki/Outer_Banks)—they all basically disappear.\n\nTo fix this, we can use `st_intersection()` to identify the intersections of all the state shapes (see [this](https://ikashnitsky.phd/2023/map-borders/) and [this](https://stackoverflow.com/a/57138069) for more details)\n\nNow all the islands and coastlines have much better definition and the borders between states are truly sized at 0.25:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninterior_state_borders <- st_intersection(us_states) |>\n  filter(n.overlaps > 1) |> \n  # Remove weird points that st_intersection() adds\n  filter(!(st_geometry_type(geometry) %in% c(\"POINT\", \"MULTIPOINT\")))\n\nggplot() +\n  geom_sf(data = us_states, fill = \"#0074D9\", linewidth = 0) +\n  geom_sf(data = interior_state_borders, linewidth = 0.25, color = \"white\") +\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-interior-borders-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Map with horizontal gradient step legend\n\nNow that we have cleaned and adjusted geographic and unemployment data, we can make a fancy map! Instead of building this sequentially, I've included all the code all at once, with lots of comments at each step.\n\nA few things to note:\n\n- `scale_fill_stepsn()` lets you use [distinct bins of color](https://ggplot2.tidyverse.org/reference/scale_steps.html) instead of a continuous gradient\n\n- We position the legend inside the plot with `theme(legend.position = \"inside\", legend.position.inside = c(0.86, 0.32))`. Those `0.86, 0.32` coordinates took a lot of tinkering to get! The units for `legend.position.inside` are based on percentages of the plot, so the legend appears where x is 86% across and 32% up. **The position changes every time the plot dimensions change.** To make life easier as I played with different values, I used [{ggview}](https://github.com/idmn/ggview) to specify and lock in exact dimensions of the plot:\n\n  ```{.r}\n  library(ggview)\n  \n  p <- ggplot(...) +\n    geom_sf(...)\n  \n  p + canvas(7, 5)\n  ```\n\n  I'm not using `ggview::canvas()` here in the post because I'm specifying figure dimensions with Quarto chunk options instead (`fig-width: 7` and `fig-height: 5`).\n\nHere's the map!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  # Add counties filled with unemployment levels\n  geom_sf(\n    data = counties_with_unemp, aes(fill = unemp_truncated), linewidth = 0\n  ) +\n  # Add interior state boundaries\n  geom_sf(\n    data = interior_state_borders, color = \"white\", linewidth = 0.25\n  ) +\n  # Show the unemployment legend as steps instead of a standard gradient\n  scale_fill_stepsn(\n    colours = scales::brewer_pal(palette = \"YlGnBu\")(9),\n    breaks = 1:10,\n    limits = c(1, 10),\n    # Change the label for >9%\n    labels = case_match(\n      1:10,\n      1 ~ \"1%\",\n      10 ~ \">9%\",\n      .default = as.character(1:10)\n    )\n  ) +\n  # Yay labels\n  labs(\n    title = \"US unemployment rates\",\n    subtitle = \"2016 annual averages by county\",\n    caption = \"Source: US Bureau of Labor Statistics\",\n    fill = \"Unemployment rate\"\n  ) +\n  # Use Albers projection and new x-axis limits\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded) +\n  # Theme adjustments\n  theme_fancy_map() +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.86, 0.32),\n    legend.direction = \"horizontal\",\n    legend.text = element_text(size = rel(0.55)),\n    legend.title = element_text(hjust = 0.5, face = \"bold\", size = rel(0.7), margin = margin(t = 3)),\n    legend.title.position = \"bottom\",\n    legend.key.width = unit(1.55, \"lines\"),\n    legend.key.height = unit(0.7, \"lines\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-horizontal-legend-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Map with histogram legend\n\nWe can replace the step gradient legend with a histogram that is filled using the same colors as the step legend. \n\nThe easiest method that gives us the most control over the legend histogram is to create a separate plot object for the histogram and place it inside the map with [{patchwork}'s `inset_element()`](https://patchwork.data-imaginist.com/articles/guides/layout.html#insets). \n\nHere's the histogram, again with comments at each step. Only one neat trick to note here:\n\n- `geom_histogram` automatically determines the bin width for the variable assigned to the x aesthetic. In order to fill each bar by bin-specific color, we need to access information about those newly created bins. [We can do this with `after_stat()`](https://yjunechoe.github.io/posts/2022-03-10-ggplot2-delayed-aes-1/)—here we fill each bar using the already-calculated x bin categories with `fill = after_stat(factor(x))`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist_legend <- ggplot(bls_2016, aes(x = unemp_truncated)) +\n  # Fill each histogram bar using the x axis category that ggplot creates\n  geom_histogram(\n    aes(fill = after_stat(factor(x))), \n    binwidth = 1, boundary = 0, color = \"white\"\n  ) +\n  # Fill with the same palette as the map\n  scale_fill_brewer(palette = \"YlGnBu\", guide = \"none\") +\n  # Modify the x-axis labels to use >9%\n  scale_x_continuous(\n    breaks = 2:10, \n    labels = case_match(\n      2:10,\n      2 ~ \"2%\",\n      10 ~ \">9%\",\n      .default = as.character(2:10)\n    )\n  ) +\n  # Just one label to replicate the legend title\n  labs(x = \"Unemployment rate\") +\n  # Theme adjustments\n  theme_fancy_map() +\n  theme(\n    axis.text.x = element_text(size = rel(0.55)),\n    axis.title.x = element_text(size = rel(0.68), margin = margin(t = 3, b = 3), face = \"bold\")\n  )\nhist_legend\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-histogram-legend-alone-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nNext, we'll place that `hist_legend` plot inside a map with `inset_element()`. Like `legend.position.inside = c(0.86, 0.32)` in the previous map, the `left = 0.75, bottom = 0.26, right = 0.98, top = 0.5` values here are percentages of the plot area and they're fully dependent on the overall dimensions of the plot. Getting these exact numbers took a lot of manual adjusting, and `ggview::canvas()` was once again indispensable for keeping the plot dimensions constant.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nunemp_map <- ggplot() +\n  # Add counties filled with unemployment levels\n  geom_sf(\n    data = counties_with_unemp, aes(fill = unemp_truncated), color = NA, linewidth = 0\n  ) +\n  # Add interior state boundaries\n  geom_sf(\n    data = interior_state_borders, color = \"white\", linewidth = 0.25, fill = NA\n  ) +\n  # Show the unemployment legend as steps instead of a standard gradient, but\n  # don't actually show the legend\n  scale_fill_stepsn(\n    colours = scales::brewer_pal(palette = \"YlGnBu\")(9),\n    breaks = 1:10, \n    guide = \"none\"\n  ) +\n  # Yay labels\n  labs(\n    title = \"US unemployment rates\",\n    subtitle = \"2016 annual averages by county\",\n    caption = \"Source: US Bureau of Labor Statistics\"\n  ) +\n  # Use Albers projection and new x-axis limits\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded) +\n  # Theme stuff\n  theme_fancy_map()\n\n# Add the histogram to the map\ncombined_map_hist <- unemp_map + \n  inset_element(hist_legend, left = 0.75, bottom = 0.26, right = 0.98, top = 0.45)\ncombined_map_hist\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-histogram-legend-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n# Map with automatic histogram legend with {legendry}\n\nFinally, [the new {legendry} package](https://teunbrand.github.io/legendry/) makes it so we can create a custom histogram-based legend without needing to use {patchwork} with a separate histogram plot!\n\nIt doesn't provide as much control over the resulting histogram. The `gizmo_histogram()` function uses base R's `hist()` behind the scenes, so we have to specify bin widths and other settings in `hist.arg` as base R arguments, like `breaks = 10` instead of ggplot's `binwidth = 10`. \n\nNot all of `hist()`'s options seem to work here. For instance, I get a warning if I use `border = \"white\"` to add a white border around each bar (`argument ‘border’ is not made use of`), since that border option is disabled when using base R's `hist()` with `plot = FALSE`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist(counties_with_unemp$unemp_truncated, breaks = 10, border = \"white\", plot = FALSE)\n## Warning in hist.default(counties_with_unemp$unemp_truncated, breaks = 10, : argument 'border' is not made use of\n## $breaks\n##  [1]  1  2  3  4  5  6  7  8  9 10\n## \n## $counts\n## [1]  12 244 589 821 644 410 205  97 119\n## \n## $density\n## [1] 0.00382 0.07768 0.18752 0.26138 0.20503 0.13053 0.06527 0.03088 0.03789\n## \n## $mids\n## [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5\n## \n## $xname\n## [1] \"counties_with_unemp$unemp_truncated\"\n## \n## $equidist\n## [1] TRUE\n## \n## attr(,\"class\")\n## [1] \"histogram\"\n```\n:::\n\n\nAlso, it's currently filling each histogram bar with the full gradient, not the 9 distinct steps, and I can't figure out how to define custom colors for each bar—and it might not even be possible since color settings aren't picked up anyway because of {legendry}'s use of `plot = FALSE` 🤷‍♂️.\n\nBut despite these downsides, this automatic histogram legend with {legendry} is really neat!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(legendry)\n\n# Create a custom histogram guide\nhistogram_guide <- compose_sandwich(\n  middle = gizmo_histogram(just = 0, hist.arg = list(breaks = 10)),\n  text = \"axis_base\"\n)\n\nggplot() +\n  # Add counties filled with unemployment levels\n  geom_sf(\n    data = counties_with_unemp, aes(fill = unemp_truncated), color = NA, linewidth = 0\n  ) +\n  # Add interior state boundaries\n  geom_sf(\n    data = interior_state_borders, color = \"white\", linewidth = 0.25, fill = NA\n  ) +\n  # Show the unemployment legend with a custom histogram guide\n  scale_fill_stepsn(\n    colours = scales::brewer_pal(palette = \"YlGnBu\")(9),\n    breaks = 1:10,\n    limits = c(1, 10),\n    guide = histogram_guide,\n    # Change the label for >9%\n    labels = case_match(\n      1:10,\n      1 ~ \"1%\",\n      10 ~ \">9%\",\n      .default = as.character(1:10)\n    )\n  ) +\n  # Yay labels\n  labs(\n    title = \"US unemployment rates\",\n    subtitle = \"2016 annual averages by county\",\n    caption = \"Source: US Bureau of Labor Statistics\",\n    fill = \"Unemployment rate\"\n  ) +\n  # Use Albers projection and new x-axis limits\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded) +\n  # Theme stuff\n  theme_fancy_map() +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.86, 0.32),\n    legend.direction = \"horizontal\",\n    legend.text = element_text(size = rel(0.55)),\n    legend.title = element_text(hjust = 0.5, face = \"bold\", size = rel(0.7), margin = margin(t = 3)),\n    legend.title.position = \"bottom\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-histogram-legend-legendry-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Bonus! Use points instead of choropleths\n\nWe're still using choropleth maps here, which still isn't ideal for showing the idea that \"land isn't unemployed\". One solution is to plot points that are sized by population. This is pretty straightforward with {sf}—we need to convert the county polygons into single points, which we can do with `st_point_on_surface()`. Then, after a bunch of tinkering with legend options, we'll have this gorgeous map:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Convert the county polygons into single points\ncounties_with_unemp_points <- counties_with_unemp |> \n  st_point_on_surface()\n\nunemp_map_points <- ggplot() +\n  # Use a gray background\n  geom_sf(data = us_states, fill = \"gray90\", linewidth = 0) +\n  geom_sf(data = interior_state_borders, linewidth = 0.25, color = \"white\") +\n  # Include semi-transparent points with shape 21 (so there's a border)\n  geom_sf(\n    data = counties_with_unemp_points, \n    aes(size = labor_force, fill = unemp_truncated), \n    pch = 21, color = \"white\", stroke = 0.25, alpha = 0.8\n  ) +\n  # Control the size of the points in the legend\n  scale_size_continuous(\n    range = c(1, 9), labels = scales::label_comma(), \n    breaks = c(10000, 100000, 1000000),\n    # Make the points black and not have a border\n    guide = guide_legend(override.aes = list(pch = 19, color = \"black\"))\n  ) +\n  # Show the unemployment legend as steps instead of a standard gradient, but\n  # don't actually show the legend\n  scale_fill_stepsn(\n    colours = scales::brewer_pal(palette = \"YlGnBu\")(9),\n    breaks = 1:10, \n    guide = \"none\"\n  ) +\n  # Labels\n  labs(\n    title = \"US unemployment rates\",\n    subtitle = \"2016 annual averages by county\",\n    caption = \"Source: US Bureau of Labor Statistics\",\n    fill = \"Unemployment rate\",\n    size = \"Labor force\"\n  ) +\n  # Albers\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded) +\n  # Theme stuff\n  theme_fancy_map() +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.837, 0.13),\n    legend.text = element_text(size = rel(0.55)),\n    legend.title = element_text(hjust = 0.5, face = \"bold\", size = rel(0.7), margin = margin(t = 3)),\n    legend.title.position = \"bottom\"\n  )\n\n# Add the histogram to the map\ncombined_map_hist_points <- unemp_map_points + \n  inset_element(hist_legend, left = 0.75, bottom = 0.26, right = 0.98, top = 0.45)\ncombined_map_hist_points\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-histogram-points-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Bonus #2! Use a diverging color scheme + nested legend circles\n\nBut wait, there's more! Based on discussions with really smart dataviz people on Bluesky in the wake of [me posting about this blog post there](https://bsky.app/profile/andrew.heiss.phd/post/3like2os2d22c), we can make two additional tweaks:\n\n- While the different sizes for the points are neat, I'm not a fan of how big the vertical spacing is between the 10,000; 100,000; and 1,000,000. Unfortunately there's no way to change it. Technically we can use `legend.key.spacing.y` in `theme()` to adjust it, but that doesn't work as expected here because each of those legend entries is sized to match the largest point—i.e., the point for 1,000,000 is the biggest, so the legend entries for all the other values match its height, even if they don't need all that space.\n\n  To fix this, we can use `guide_circles()` from {legendry} to show the different point sizes as coencentric circles, which is more compact (and just looks neat).\n\n- Instead of showing a range of low → high values, [we can color these counties based on a meaningful midpoint](https://bsky.app/profile/abmakulec.bsky.social/post/3limfykl2i22n) to help highlight which counties are doing great (low unemployment! good!) and which aren't (high unemployment! bad!). That might not always necessarily be the best approach—showing the full range of actual values like in the original map is a way of just describing the range and doesn't inherently imply good or bad. But in other plots where data might be more actionable, divergences from some central value would be much more helpful.\n\n  In the United States, the Federal Reserve has a [unique dual mandate](https://www.stlouisfed.org/in-plain-english/the-fed-and-the-dual-mandate) to use macroeconomic policies to target both inflation and unemployment (most other countries' central banks only target inflation). The Fed typically aims for an inflation rate of 2% and an unemployment rate of [4ish%](https://www.marketplace.org/2024/07/29/what-is-maximum-employment-target/). So in this new map, we'll center each county's unemployment rate around 4% and show the percentage point deviations from that Fed target. Counties colored in darker red have higher unemployment rates than the target; counties colored in blue have lower rates than the target.\n\n  We can then imagine that we're a policymaker interested in unemployment trends—we can look at the map and quickly identify areas that are doing poorly and doing well.\n\nUp at the beginning of the document where we loaded and cleaned the `bls_2016` dataset, I've added a new variable that centers the unemployment rate at 4:\n\n```{.r}\nmutate(unemp_diff = unemp_truncated - 4)\n```\n\nWe can then use this to create a new histogram and new map colored with the \"vik\" palette from [the {scico} package](https://github.com/thomasp85/scico), which has lots of [neat diverging palettes](https://www.fabiocrameri.ch/colourmaps/). We'll also create a fancy circle-based legend with {legendry}. Here's the fully annotated code and final map:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggtext)  # For Markdown-based text in ggplot\nlibrary(scico)   # For perceptually uniform colors\n\n# Make new histogram legend\nhist_legend_diffs <- ggplot(bls_2016, aes(x = unemp_diff)) +\n  # Fill each histogram bar using the x axis category that ggplot creates\n  # Use boundary = 0.5 to shift the bin ranges from things like 1-2 to 1.5-2.5\n  geom_histogram(\n    aes(fill = after_stat((x))), \n    binwidth = 1, boundary = 0.5, color = \"white\"\n  ) +\n  # Fill with the same palette as the map\n  # scale_fill_brewer(palette = \"YlGnBu\", guide = \"none\") +\n  scale_fill_scico(palette = \"vik\", midpoint = 0, guide = \"none\") +\n  # Modify the x-axis labels to show perentage point values and format them with\n  # markdown to get original unemployment values on separate lines\n  scale_x_continuous(\n    breaks = -2:5, \n    labels = case_match(\n      -2:5,\n      -2 ~ \"**−2 pp.**<br>(2%)\",\n      0 ~ \"**0**<br>(4% ±<br>0.5 pp.)\",\n      5 ~ \"**>+4 pp.**<br>(>9%)\",\n      .default = glue::glue(\n        \"**{x}**\", \n        x = scales::label_comma(\n          style_positive = \"plus\", style_negative = \"minus\"\n        )(-2:5))\n    )\n  ) +\n  # Just one label to replicate the legend title\n  labs(x = \"Difference from Fed target\") +\n  # Theme adjustments\n  theme_fancy_map() +\n  theme(\n    axis.text.x = element_markdown(size = rel(0.5), vjust = 1, lineheight = 1.3),\n    axis.title.x = element_text(size = rel(0.68), margin = margin(t = 3, b = 3), face = \"bold\")\n  )\n\nunemp_map_points_diffs <- ggplot() +\n  # Use a lighter gray background\n  geom_sf(data = us_states, fill = \"gray95\", linewidth = 0) +\n  # Use slightly darker state borders\n  geom_sf(data = interior_state_borders, linewidth = 0.25, color = \"grey60\") +\n  # Include semi-transparent points with shape 21 (so there's a border)\n  geom_sf(\n    data = counties_with_unemp_points, \n    aes(size = labor_force, fill = unemp_diff), \n    shape = 21, color = \"white\", stroke = 0.25, alpha = 0.8\n  ) +\n  # Control the size of the points in the legend\n  scale_size_continuous(\n    range = c(1, 11), labels = scales::label_comma(), \n    breaks = c(100000, 1000000, 5000000),\n    # Make the points black and not have a border\n    guide = guide_circles(\n      text_position = \"right\",\n      override.aes = list(\n        fill = \"grey30\", alpha = 0.8\n      )\n    )\n  ) +\n  # This is tricky! We want to use the diverging vik palette but have it \n  # centered at 0. With scale_fill_scico(), there's a midpoint argument, like we \n  # used for the histogram. For generating regular lists of colors with scico(), \n  # though, there's no midpoint argument. Instead, we need to make a few \n  # specific adjustments: \n  #\n  # 1. Generate 11 possible colors, since there are 5 colors above the 0 \n  #    midpoint in the histogram and we need 5 parallel negative colors below 0 \n  #    (even though we're only using 2)\n  # 2. Set the limits of the legend to the symmetrical -5 to 5 range so that \n  #    it's centered at 0\n  # 3. Set the breaks to go asymmetrically from -2:5. But actually set them \n  #    from -2.5 to 4.5 since that matches the shifted histogram, which uses a \n  #    boundary of 0.5 instead of 0 (so the histogram bins cover ranges like \n  #    0.5 to 1.5 instead of 0 to 1)\n  scale_fill_stepsn(\n    colours = scico::scico(11, palette = \"vik\"),\n    limits = c(-5, 5),\n    breaks = seq(-2.5, 4.5, by = 1),\n    guide = \"none\"\n  ) +\n  # Labels\n  labs(\n    title = \"US unemployment (2016)\",\n    subtitle = \"Differences from the Federal Reserve's 4% target\",\n    caption = \"Source: US Bureau of Labor Statistics\",\n    fill = \"Unemployment rate\",\n    size = \"County labor force\"\n  ) +\n  # Albers\n  coord_sf(crs = st_crs(\"ESRI:102003\"), xlim = xlim_expanded) +\n  # Theme adjustments\n  theme_fancy_map() +\n  theme(\n    # {legendry} complains if there's no legend.margin setting; using \n    # theme_void() removes that setting and breaks the plot, so we specify \n    # some 0 values here\n    legend.margin = margin(0, 0, 0, 0, \"pt\"),\n    legendry.legend.key.margin = margin(0, 5, 0, 0, \"pt\"),\n    legend.ticks = element_line(colour = \"black\", linetype = \"22\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.87, 0.17),\n    legend.text = element_text(size = rel(0.55)),\n    legend.title = element_text(hjust = 0.5, face = \"bold\", size = rel(0.7), margin = margin(t = 3)),\n    plot.subtitle = element_text(hjust = 0.18),\n    legend.title.position = \"bottom\"\n  )\n\n# Add the histogram to the map\ncombined_map_hist_points_diffs <- unemp_map_points_diffs + \n  inset_element(hist_legend_diffs, left = 0.75, bottom = 0.26, right = 0.98, top = 0.45)\ncombined_map_hist_points_diffs\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-histogram-points-diffs-1.png){fig-align='center' width=100%}\n:::\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}