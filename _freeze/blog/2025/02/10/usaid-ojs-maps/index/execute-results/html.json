{
  "hash": "4340c392fed469248dca45f565831662",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Using USAID data to make fancy world maps with Observable Plot\"\ndate: 2025-02-10\ndescription: \"Manipulate geographic data, change projections, get live data from a database, and make interactive plots with Observable JS\"\n\nimage: img/final-plot.png\ntwitter-card: \n    image: \"img/final-plot.png\"\nopen-graph: \n    image: \"img/final-plot.png\"\n\ncategories:\n  - ojs\n  - observable plot\n  - gis\n  - maps\n  - usaid\n\nformat:\n  html:\n    shift-heading-level-by: 1\n    toc-depth: 4\n    highlight-style: arrow\n    toc-expand: true\n\n    include-in-header:\n      - text: |\n          <style type=\"text/css\">\n          div.sourceCode > pre.sourceCode.js::before {\n            content: 'Observable JS';\n            display: block;\n            text-align: left;\n            font-size: 1em;\n            margin-bottom: 7px;\n            border-bottom: #dddddd 1px solid;\n            padding-left: 4.25px;\n            padding-bottom: 5px;\n            color: #aaaaaa;\n          }\n\n          div.sourceCode > pre.sourceCode.r::before {\n            content: 'R';\n            display: block;\n            text-align: left;\n            font-size: 1em;\n            margin-bottom: 7px;\n            border-bottom: #dddddd 1px solid;\n            padding-left: 4.25px;\n            padding-bottom: 5px;\n            color: #aaaaaa;\n          }\n\n          div.sourceCode > pre.sourceCode.sql::before {\n            content: 'SQL';\n            display: block;\n            text-align: left;\n            font-size: 1em;\n            margin-bottom: 7px;\n            border-bottom: #dddddd 1px solid;\n            padding-left: 4.25px;\n            padding-bottom: 5px;\n            color: #aaaaaa;\n          }\n          </style>\n\nfilters:\n  - line-highlight\n\nresources:\n  - \"recipient_countries.csv\"\n\ndoi: 10.59350/c0aep-hp989\ncitation: true\n---\n\n\n\nAs part of Elon Musk's weird Department of Government Efficiency's unconstitutional rampage through the federal government, USAID's ForeignAssistance.gov was taken offline on January 31, 2025. It reappeared on February 3, but it's not clear how long it will be available, especially as USAID is gutted (despite court orders and injunctions to stop).\n\nI study civil society, human rights, and foreign aid and rely on USAID aid data for several of my [research projects](https://www.andrewheiss.com/research/working-papers/chaudhry-heiss-ngos-aid/), so as a backup, I used [Datasette](https://datasette.io/) to create a mirror website/API of the entire ForeignAssistance.gov dataset at <https://foreignassistance-data.andrewheiss.com/>. Everything as of December 19, 2024 is available there, both as a queryable SQL database and as downloadable CSV files.\n\nI also made [a little frontend website](https://foreignassistance.andrewheiss.com/) with links to each individual dataset. As I built that website, I decided to try recreating the ForeignAssistance.gov dashboard, which had neat interactive maps and tables.\n\n![ForeignAssistance.gov dashboard](img/foreign-assistance-gov.png){.border width=\"80%\"}\n\nSince [Quarto has native support](https://quarto.org/docs/interactive/ojs/) for [Observable JS](https://observablehq.com/@observablehq/observables-not-javascript) for interactive work, and since I've meant to really dig into Observable and figure out how to make more interactive graphs, I figured I'd play around with the rescued USAID data.\n\nSo in this post, I show what I learned about working with geographic data and making pretty maps with [Observable Plot](https://observablehq.com/plot/getting-started),\n\n::: {.callout-warning}\n#### Caveat!\n\nI'm really bad at Javascript! The code here is probably wildly inefficient and feels R-flavored.\n\nBut it works, and that's all that matters :)\n:::\n\n# Working with map data\n\n## Get map data\n\nObservable Plot uses the [`d3-geo`](https://github.com/d3/d3-geo) module behind the scenes to parse and work with map data, and D3 typically works with data formatted as [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON). There are tons of high quality geographic data sources online, like the ~~US Census~~ (they've been removing those in the past few weeks), [IPUMS NHGIS](https://www.nhgis.org/), [IPUMS IHGIS](https://ihgis.ipums.org/), and the [Natural Earth project](https://www.naturalearthdata.com/), and cities and states typically offer GIS data for public sector-related data. These data sources tend to be stored as [shapefiles](https://en.wikipedia.org/wiki/Shapefile), which are a fairly complex (but standard) format for geographic data that involve multiple files.\n\nObservable Plot/D3 might be able to work with shapefiles directly, but it's nowhere in the documentation. They seem to expect GeoJSON instead. We could hunt around online for GeoJSON data, but—even better—we can use the {sf} package in R to convert any shapefile-based data into GeoJSON by setting `driver = \"GeoJSON\"` in `sf::st_write()`. Here we'll load two datasets from Natural Earth—(1) small scale low resolution 1:110m data for mapping the whole world and (2) medium scale 1:50m data for mapping specific regions and countries—and convert them to GeoJSON files.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(rnaturalearth)\n\n# Get low resolution Natural Earth data as map units instead of countries because of France\nworld <- ne_countries(scale = 110, type = \"map_units\")\n\n# Save as geojson for Observable Plot\nst_write(\n  obj = world, \n  dsn = \"ne_110m_admin_0_countries.geojson\", \n  driver = \"GeoJSON\"\n)\n\n# Save medium resolution geojson\nst_write(\n  obj = ne_countries(scale = 50, type = \"countries\"), \n  dsn = \"ne_50m_admin_0_countries.geojson\", \n  driver = \"GeoJSON\"\n)\n```\n:::\n\n\n\n::: {.callout-note}\n#### Maybe skip intermediate saving?\n\nWe could probably use [Quarto's special R-to-OJS function `ojs_define()`](https://quarto.org/docs/interactive/ojs/data-sources.html#python-and-r) and make these R objects directly accessible to OJS without needing to save intermediate files:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nojs_define(world = ne_countries(scale = 110, type = \"map_units\"))\n```\n:::\n\n\n\n…but geographic data is complex and I don't know how things like Observable Plot's `Plot.geo()` handle data that's not read as GeoJSON. So to keep things simple, I ended up just saving these as GeoJSON. 🤷‍♂️\n:::\n\n\n## Maps and projections with Observable Plot\n\nWe can load these into our document with OJS with `FileAttachment()`:\n\n\n\n```{ojs}\nworld = FileAttachment(\"ne_110m_admin_0_countries.geojson\").json()\nworld_medium = FileAttachment(\"ne_50m_admin_0_countries.geojson\").json()\n```\n\n\n\nCheck out the structure of `world`. It's a `FeatureCollection` with a slot named `crs` with the projection information and a slot named `features` with entries for each country. Each country `Feature` has a slot named `properties` with columns like `name`, `iso_a3`, `formal_en`, `pop_est`, and other details.\n\n\n\n```{ojs}\nworld\n```\n\n\n\nTo plot it, we can use [the `Geo` mark](https://observablehq.com/plot/marks/geo):\n\n\n\n```{ojs}\nPlot.plot({\n  marks: [\n    Plot.geo(world)\n  ]\n})\n```\n\n\n\nTo make things look nicer throughout this post, we'll define some nicer colors for countries and land and ocean from [CARTOColors](https://carto.com/carto-colors/):\n\n\n\n```{ojs}\n// CARTOColors Prism\ncarto_prism = [\n  \"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \n  \"#E17C05\", \"#CC503E\", \"#94346E\", \"#6F4070\", \"#994E95\", \"#666666\"\n]\n\n// From R:\n// clr_ocean <- colorspace::lighten(\"#88CCEE\", 0.7)\nclr_ocean = \"#D9F0FF\"\n\n// From CARTOColors Peach 2\nclr_land = \"#facba6\"\n```\n\n\n\nWe'll make the land be orange-ish, add some thin black borders around the countries, and include a blue background color with `Plot.frame()`:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  marks: [\n    Plot.frame({ fill: clr_ocean }),  //<<\n    Plot.geo(world, { //<<\n      stroke: \"black\", //<<\n      strokeWidth: 0.5, //<<\n      fill: clr_land //<<\n    }) //<<\n  ]\n})\n```\n\n\n\n### Built-in projections\n\nTaking a round globe and smashing it on a two-dimensional surface [always requires geometric shenanigans to get things flat](https://datavizsp25.classes.andrewheiss.com/example/12-example.html#projections-and-coordinate-reference-systems). We can control how things get flattened by specifying the projection for the map. Here we'll use the [Equal Earth projection](https://en.wikipedia.org/wiki/Equal_Earth_projection) (invented in 2018 to show countries and continents at their true relative sizes to each other). Since projections contain relative height and width details, we need to specify a width for the plot now. I arbitrarily chose 1000 pixels here, which is the maximum width—it should autoshrink in smaller browser windows, and the height should be calculated automatically. Finally, instead of adding the background color with `Plot.frame()`, we can use `Plot.sphere()` to get a nicer background that uses the specified projection:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: \"equal-earth\", //<<\n  width: 1000, //<<\n  marks: [\n    Plot.sphere({ fill: clr_ocean }), //<<\n    Plot.geo(world, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nThe Observable Plot library [includes a bunch of common built-in projections](https://observablehq.com/plot/features/projections#projection-options):\n\n:::{.column-body-outset}\n\n\n\n```{ojs}\n//| panel: sidebar\n//| echo: false\n\nviewof projection = Inputs.select(\n  [\"equirectangular\", \"equal-earth\", \"mercator\", \"transverse-mercator\", \"azimuthal-equal-area\", \"gnomonic\"],\n  {value: \"azimuthal-equal-area\", label: \"Projection\"}\n)\n```\n\n```{ojs}\n//| panel: fill\n//| echo: false\n\nPlot.plot({\n  projection: projection,\n  // width,\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\n:::\n\n### Other projections\n\nObservable Plot can support any other D3 projection too. There are a whole bunch of projections in the [main `d3-geo` module](https://github.com/d3/d3-geo), and there's a separate [`d3-geo-projection`](https://github.com/d3/d3-geo-projection) module for dozens of others. My favorite global projection is [Robinson](https://en.wikipedia.org/wiki/Robinson_projection) (the foundation for Equal Earth), which lives in `d3-geo-projection`. To use it, we can import the module with `require()` and then access it with `d3_geo_projection.geoRobinson()`:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nd3_geo_projection = require(\"d3-geo-projection\") //<<\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(), //<<\n  width: 1000,\n  height: 500, //<<\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\n\n## Filtering map data and adjusting projections\n\n### Removing elements\n\nNow that we have a nice projection, we can tweak the map a little. Antarctica is taking up a big proportion of the southern hemisphere, so we'll filter it out. The `world` object that has all the map data keeps each country object inside a `features` slot:\n\n\n\n```{ojs}\nworld.features\n```\n\n\n\nWe can filter it using Javascript's `.filter()` function. To make sure that the resulting array keeps the geographic-ness of the data and is a `FeatureCollection`, we need to create a similarly structured object, with `type` and `features` slots:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\n// Antarctica's ISO3 code is ATA\nworld_sans_penguins = ({ //<<\n  type: \"FeatureCollection\", //<<\n  features: world.features.filter(d => d.properties.iso_a3 !== \"ATA\") //<<\n}) //<<\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 500,\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_sans_penguins, { //<<\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nThat works and Antarctica is gone, as expected, but in reality the map didn't actually change that much. Even if we stop using the sphere background and just fill the plot frame, we can see that the area where Antarctica was is still there, it's just missing the land itself:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 500,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }), //<<\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\n### Quick and dirty cheating method: change the width or height\n\nOne quick and dirty solution is to mess with the dimensions and shrink the height. After some trial and error, 430 pixels looks good:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 430, //<<\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nWhile this works in this case, **it's not a universal solution**. The only reason this works is because Antarctica happens to be at the bottom of the map. When you adjust the height of the plot area, the map itself is *anchored to the top*. Like, if we set the height to 215, we'll get just the northern hemisphere:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 215, //<<\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nAs far as I can tell, there's no way to anchor the map in any other position. If we filter the map data to only look at one continent, there's no easy way to focus on just that continent by adjusting only the `width` or `height` options. Here's Africa all by itself in a big empty plot area:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\njust_africa = ({ //<<\n    type: \"FeatureCollection\", //<<\n    features: world.features.filter(d => d.properties.continent == \"Africa\") //<<\n}) //<<\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 430, //<<\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(just_africa, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nIf we adjust the width or the height, the plot area will be resized with the map anchored in the top left corner so we're left with just the northwestern part of Africa (and big empty areas where North America, South America, and Europe would be):\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 550, //<<\n  height: 215, //<<\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(just_africa, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nThat's not great, but there are better ways!\n\n### Built-in projections and domain settings\n\nThe official Observable Plot method for fitting the plot window to a specific area of the map is to define a \"domain\" for one of the built-in projections to zoom in on specific areas. [The documentation shows](https://observablehq.com/plot/features/projections#projections) how to use special functions in `d3-geo` to create a circle around a point, but you can also pass a GeoJSON object and Plot will use its boundaries for the domain. The built-in projection options also let us control the outside margin of the domain with `inset`.\n\nHere's the world map without Antarctica with the Equal Earth projection, with the projection resized to fit within the bounds of `world_sans_penguins`, with 10 pixels of padding around the landmass. Antarctica is gone now and the rest of the map is vertically centered within the plot area:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: { //<<\n    type: \"equal-earth\", //<<\n    domain: world_sans_penguins, //<<\n    inset: 10 //<<\n  }, //<<\n  width: 1000,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nWe can see what's happening behind the scenes if we add `Plot.sphere()` back in. The rounded globe area is still there, but it's shifted down and out of the frame. We're essentially panning around and zooming in on the Equal Earth projection:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: {\n    type: \"equal-earth\",\n    domain: world_sans_penguins, \n    inset: 10\n  },\n  width: 1000,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1 }), //<<\n    Plot.sphere({ fill: clr_ocean }), //<<\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nPassing a GeoJSON object as the domain is really neat because it makes it straightforward to zoom in on specific areas. For instance, here's the complete medium resolution world map zoomed in around the `just_africa` object, which keeps non-African countries in the Middle East and southern Europe:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: {\n    type: \"equal-earth\",\n    domain: just_africa, //<<\n    inset: 10\n  },\n  width: 600, //<<\n  height: 600, //<<\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_medium, { //<<\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nWe could also extract Africa from the medium resolution world map and plot only that continent, omitting the Middle East and Europe:\n\n\n\n```{ojs}\n//| ht-pattern: \"//<<\"\n\njust_africa_medium = ({ //<<\n    type: \"FeatureCollection\", //<<\n    features: world_medium.features.filter(d => d.properties.continent == \"Africa\") //<<\n}) //<<\n\nPlot.plot({\n  projection: {\n    type: \"equal-earth\",\n    domain: just_africa,\n    inset: 10\n  },\n  width: 600,\n  height: 600,\n  marks: [\n    // Use a white background since we don't want to make it look like  //<<\n    // the Sinai peninsula has a coastline  //<<\n    Plot.frame({ fill: \"white\", stroke: \"black\", strokeWidth: 1 }), //<<\n    Plot.geo(just_africa_medium, {  //<<\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\n### Other projections and `.fitExtent()`\n\nUnfortunately, it's a little bit trickier to set the domain and inset for projections that aren't built in to Plot. We *can't* do this:\n\n```{.js}\nPlot.plot({\n  projection: {\n    type: d3_geo_projection.geoRobinson(),\n    domain: world_sans_penguins,\n    inset: 10\n  },\n  ...\n})\n```\n\nInstead, we need to adjust the size of the projection window itself and build in the inset with [`d3-geo`'s `.fitExtent()`](https://d3js.org/d3-geo/projection#projection_fitExtent). This function takes four arguments in an array like `[[x1, y1], [x2, y2]]`, defining the top left and bottom right corners (in pixels) of a window that is centered in the middle of a given GeoJSON object. Here, for instance, we create a copy of the Robinson projection that has a window around `just_africa` with a top left corner at (30, 30) and a bottom right corner at (570, 570):\n\n\n\n```{ojs}\ninset_africa = 30\nafrica_map_width = 600\nafrica_map_height = 600\n\nafrica_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_africa, inset_africa],  // Top left\n     [africa_map_width - inset_africa, africa_map_height - inset_africa]],  // Bottom right \n    just_africa\n  )\n\nPlot.plot({\n  projection: africa_robinson,\n  width: africa_map_width,\n  height: africa_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\nWe can use the same approach with individual countries. For extra fun, we'll fill these countries with distinct colors using Natural Earth's `mapcolor7` column, which assigns countries one of 7 different colors that don't border other countries (so neighboring countries will never be the same color). We'll also add some labels in the middle of each country.\n\n\n\n```{ojs}\negypt = world_medium.features.find(d => d.properties.name === \"Egypt\")\n\ninset_egypt = 75\negypt_map_width = 600\negypt_map_height = 600\n\nrobinson_egypt = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_egypt, inset_egypt],  // Top left\n     [egypt_map_width - inset_egypt, egypt_map_height - inset_egypt]],  // Bottom right\n    egypt\n  )\n\nPlot.plot({\n  projection: robinson_egypt,\n  width: egypt_map_width,\n  height: egypt_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_medium, Plot.centroid({\n      fill: d => d.properties.mapcolor7,\n      stroke: \"black\", \n      strokeWidth: 0.5\n    })),\n    Plot.geo(egypt, { stroke: \"yellow\", strokeWidth: 3 }),\n    Plot.tip(world_medium.features, Plot.centroid({\n      title: d => d.properties.name, \n      anchor: \"top\",\n      fontSize: 13,\n      fontWeight: \"bold\",\n      textPadding: 3\n    }))\n  ],\n  color: {\n    range: carto_prism\n  }\n})\n\n```\n\n\n\nThe approach works for the whole `world_sans_penguins` object as well. This addresses our original problem—here's a world map with the Robinson projection *without* Antarctica that fills the plot area correctly:\n\n\n\n```{ojs}\ninset_world = 10\nworld_map_width = 1000\nworld_map_height = 450\n\nworld_sans_penguins_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_world, inset_world],\n     [world_map_width - inset_world, world_map_height - inset_world]],\n    world_sans_penguins\n  )\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n```\n\n\n\n### Arbitrary areas and `.fitExtent()`\n\nFor bonus fun, this approach also works for any arbitrary rectangles. For example, we can use [OpenStreetMap's neat Export tool](https://www.openstreetmap.org/export#map=4/49.07/4.00) to pick the top, bottom, left, and right edges of a box that focuses on Western Europe.\n\n![Rectangle around western Europe with OpenStreetMap's Export tool](img/osm-export.png){width=\"80%\"}\n\nWe can then use those coordinates to create a `MultiPoint` geometric feature/object, which essentially acts like a rectangular fake country/region that can be used as the domain or extent of the map:\n\n\n\n```{ojs}\ninset_europe = 10\neurope_map_width = 800\neurope_map_height = 800\n\neurope_box = ({\n  type: \"Feature\",\n  geometry: {\n    type: \"MultiPoint\",\n    coordinates: [\n      [-13, 35],  // [left/west, bottom/south] (or bottom left corner)\n      [21, 60]    // [right/east, top/north]   (or top right corner)\n    ]\n  }\n})\n\neurope_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_europe, inset_europe],\n     [europe_map_width - inset_europe, europe_map_height - inset_europe]], \n    europe_box\n  )\n\nPlot.plot({\n  projection: europe_robinson,\n  width: europe_map_width,\n  height: europe_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_medium, Plot.centroid({\n      fill: d => d.properties.mapcolor9,\n      stroke: \"white\", \n      strokeWidth: 0.25\n    })),\n    Plot.tip(world.features, Plot.centroid({\n      title: d => d.properties.name, \n      anchor: \"bottom\",\n      fontSize: 13,\n      fontWeight: \"bold\",\n      textPadding: 3\n    }))\n  ],\n  color: {\n    range: carto_prism\n  }\n})\n```\n\n\n\n\n# Working with USAID data\n\n## Get USAID data\n\nTo make it easier to access and filter and manipulate things, I put the rescued data on a [Datasette](https://datasette.io/) instance, which is nice front-end for an SQLite database. This makes it possible to run SQL queries directly in the browser and generate custom datasets without needing to load the full massive CSV files into R or Python or Stata or whatever.\n\nFor example, one of the rescued USAID datasets is named [`us_foreign_aid_country`](https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance/~2E~2Fus_foreign_aid_country) and it contains 22,000+ rows, with data on aid obligations, appropriations, and disbursements starting in 1999.\n\nIf we want to get a total of all constant USD aid obligations by country in 2023, omitting regional and world totals, we could do something like this with R and {dplyr}:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# Download the raw CSV and put it somewhere\nus_foreign_aid_country <- read_csv(\"us_foreign_aid_country.csv\")\n\nus_foreign_aid_country |>\n  filter(\n    `Fiscal Year` == 2023, \n    `Transaction Type Name` == \"Obligations\",\n    !str_detect(`Country Name`, \"Region\"),\n    `Country Name` != \"World\"\n  ) |>\n  group_by(`Country Code`, `Country Name`, `Region Name`) |>\n  summarize(total_constant_amount = sum(constant_amount)) |>\n  arrange(desc(total_constant_amount))\n#>  A tibble: 176 × 4\n#>  Groups:   Country Code, Country Name [176]\n#>   `Country Code` `Country Name`   `Region Name`                total_constant_amount\n#>   <chr>          <chr>            <chr>                                        <dbl>\n#> 1 UKR            Ukraine          Europe and Eurasia                     17193710403\n#> 2 ISR            Israel           Middle East and North Africa            3302860882\n#> 3 JOR            Jordan           Middle East and North Africa            1686862605\n#> 4 EGY            Egypt            Middle East and North Africa            1503609426\n#> 5 ETH            Ethiopia         Sub-Saharan Africa                      1457374911\n#> 6 SOM            Somalia          Sub-Saharan Africa                      1181033990\n#> 7 NGA            Nigeria          Sub-Saharan Africa                      1019947490\n#> 8 COD            Congo (Kinshasa) Sub-Saharan Africa                       990456757\n#> 9 AFG            Afghanistan      South and Central Asia                   886536741\n#> 0 KEN            Kenya            Sub-Saharan Africa                       846303488\n#>  ℹ 166 more rows\n#>  ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n\n\nOr we could get that data extract directly from the database without needing to load the huge original CSV file. We can run [an SQL query like this](https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance?sql=SELECT+%22Country+Code%22%2C+%22Country+Name%22%2C+%22Region+Name%22%2C+SUM%28%22constant_amount%22%29+AS+total_constant_amount%0D%0A++FROM+%22.%2Fus_foreign_aid_country%22%0D%0A++WHERE+%22Fiscal+Year%22+%3D+%272023%27+%0D%0A++++AND+%22Transaction+Type+Name%22+%3D+%27Obligations%27+%0D%0A++++AND+%22Country+Name%22+NOT+LIKE+%27%25Region%25%27+%0D%0A++++AND+%22Country+Name%22+%21%3D+%22World%22%0D%0A++GROUP+BY+%22Country+Code%22%2C+%22Country+Name%22%2C+%22Region+Name%22%0D%0A++ORDER+BY+total_constant_amount+DESC%3B) at the Datasette website: \n\n```{.sql}\nSELECT \"Country Code\", \"Country Name\", \"Region Name\", SUM(\"constant_amount\") AS total_constant_amount\n  FROM \"./us_foreign_aid_country\"\n  WHERE \n    \"Fiscal Year\" = '2023' \n    AND \"Transaction Type Name\" = 'Obligations' \n    AND \"Country Name\" NOT LIKE '%Region%' \n    AND \"Country Name\" != \"World\"\n  GROUP BY \"Country Code\", \"Country Name\", \"Region Name\"\n  ORDER BY total_constant_amount DESC;\n```\n\n![SQL query and results](img/datasette-query.png){.border width=\"80%\"}\n\nSince we're working with interactive Observable Javascript, we can load that data directly into the browser instead of downloading intermediate CSV files. There's a neat [Datasette database client](https://observablehq.com/@ambassadors/datasette-client) for Observable that lets us run SQL queries (there are [lots of other clients too](https://observablehq.com/documentation/data/databases/database-clients), if you want to connect to things like DuckDB, SQLite, MySQL, Snowflake, and so on).\n\n\n\n```{ojs}\n//| eval: false\n\n// https://observablehq.com/@ambassadors/datasette-client\nimport { DatasetteClient } from \"@ambassadors/datasette-client\"\n\naid_db = new DatasetteClient(\n  \"https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance\"\n)\n\nrecipient_countries = await aid_db.sql`\n  SELECT \"Country Code\", \"Country Name\", \"Region Name\", SUM(\"constant_amount\") AS total_constant_amount\n  FROM \"./us_foreign_aid_country\"\n  WHERE \n    \"Fiscal Year\" = '2023' \n    AND \"Transaction Type Name\" = 'Obligations' \n    AND \"Country Name\" NOT LIKE '%Region%' \n    AND \"Country Name\" != \"World\"\n  GROUP BY \"Country Code\", \"Country Name\", \"Region Name\"\n  ORDER BY total_constant_amount DESC;\n`\n```\n\n\n\nThrough the magic of this Datasette client, we now have a pre-summarized dataset to work with!\n\n\n\n```{ojs}\n//| echo: false\n\n// I don't want to keep hitting the Datasette server with requests, so I'm \n// cheating and loading a CSV extract instead. It comes from this query: \n// https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance.csv?sql=SELECT+%22Country+Code%22%2C+%22Country+Name%22%2C+%22Region+Name%22%2C+SUM%28%22constant_amount%22%29+AS+total_constant_amount%0D%0A++FROM+%22.%2Fus_foreign_aid_country%22%0D%0A++WHERE+%22Fiscal+Year%22+%3D+%272023%27+%0D%0A++++AND+%22Transaction+Type+Name%22+%3D+%27Obligations%27+%0D%0A++++AND+%22Country+Name%22+NOT+LIKE+%27%25Region%25%27+%0D%0A++++AND+%22Country+Name%22+%21%3D+%22World%22%0D%0A++GROUP+BY+%22Country+Code%22%2C+%22Country+Name%22%2C+%22Region+Name%22%0D%0A++ORDER+BY+total_constant_amount+DESC%3B&_size=max\nrecipient_countries = await FileAttachment(\"recipient_countries.csv\").csv({ typed: true })\n```\n\n```{ojs}\nrecipient_countries\n```\n\n\n\n# Connect USAID data to the map data\n\n[Following Observable Plot's choropleth tutorial](https://observablehq.com/@observablehq/build-your-first-choropleth-map-with-observable-plot#cell-434), to show these totals on a map, we need to create a `Map` object,^[This term is admittedly confusing because it has nothing to do with geographic maps and is [instead related to functional programming](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).] which is like a Python dictionary or an R data frame with two columns, where we have (1) a name that shares a name with something in the geographic data, like an ISO3 country code, and (2) a value with the thing we want to plot.\n\n\n\n```{ojs}\ncountry_totals = new Map(recipient_countries.map(d => [d[\"Country Code\"], d.total_constant_amount]))\ncountry_totals\n```\n\n\n\nThis lets us get specific totals with the `.get()` method. Here's Ukraine, for example:\n\n\n\n```{ojs}\ncountry_totals.get(\"UKR\")\n```\n\n\n\nWe can feed the ISO3 code of each country-level geographic shape into this `country_totals` object to extract the total amount of aid for each country. We'll use the Antarctica-free Robinson projection we made earlier, and we'll remove the ocean fill since we'll ultimately make this interactive and hoverable:\n\n\n\n```{ojs}\n//| column: body-outset\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3)\n    }))\n  ]\n})\n```\n\n\n\n## Improving the map\n\nWe have a choropleth! But this is hardly publication worthy. We need to fix a bunch of issues with it.\n\nFirst, countries that don't receive aid don't appear in the map. Let's add borders to all the countries:\n\n\n\n```{ojs}\n//| column: body-outset\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3)\n    })),\n    Plot.geo(world_sans_penguins, {  //<<\n      stroke: \"black\",  //<<\n      strokeWidth: 0.5  //<<\n    })  //<<\n  ]\n})\n```\n\n\n\nThe coloring here is gross because of some huge outliers (Ukraine) that make most countries black/dark blue. There's also no legend to show what these values are. We can address all of this by [adjusting the legend options](https://observablehq.com/plot/features/legends#legend-options). We'll log total aid, include the legend, add a nice label, and use a [single-hue coloring scheme](https://observablehq.com/plot/features/scales#color-scales) with gray for countries without aid:\n\n\n\n```{ojs}\n//| column: body-outset\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3)\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {  //<<\n    scheme: \"blues\",  //<<\n    unknown: \"#f2f2f2\",  //<<\n    type: \"log\",   //<<\n    legend: true,  //<<\n    label: \"Total obligations\",  //<<\n  }  //<<\n})\n```\n\n\n\nNext, let's make this interactive by turning on [hovering tooltips](https://observablehq.com/plot/marks/tip):\n\n\n\n```{ojs}\n//| column: body-outset\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3),\n      tip: true //<<\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {\n    scheme: \"blues\",\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n  }\n})\n```\n\n\n\nThat's so cool. Hover over Mexico and you'll see \"**Total obligations** 232,214,023\".\n\nWe can make this tooltip more informative by including the country name and formatting the amount to show dollars. Instead of using `tip: true`, we can add the country name as a channel (Observable Plot's version of a ggplot aesthetic), and format the tip so that the country name comes first and the total amount is [formatted](https://observablehq.com/plot/features/formats) with [`d3.format()`](https://d3js.org/d3-format):\n\n\n\n```{ojs}\n//| column: body-outset\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3),\n      channels: { //<<\n        Country: d => d.properties.name, //<<\n      }, //<<\n      tip: { //<<\n        format: { //<<\n          Country: true, //<<\n          fill: d3.format(\"$,d\") //<<\n        } //<<\n      } //<<\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {\n    scheme: \"blues\",\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n  }\n})\n```\n\n\n\nNow hover over Mexico and you'll see the country name and the amount of aid in dollars.\n\n## Fixing labelling issues\n\nWe have two final super minor issues to address. \n\nFirst hover over a country that didn't receive aid, like the United States or Australia. The total reported aid displays as \"$NaN\". That's gross. It'd be nicer if it said something else, like \"$0\" or \"No aid\" or something more informative.\n\nTo fix this, we can make a little function that formats the given value as a dollar amount if it's an actual value, and formats it as something else if it's missing or not a number (like `log(0)`):\n\n\n\n```{ojs}\nfunction format_aid_total(value) {\n  return value ? d3.format(\"$,d\")(value) : \"No aid\";\n}\n```\n\n\n\nThat works nicely:\n\n\n\n```{ojs}\nformat_aid_total(394023)\nformat_aid_total(NaN)\n```\n\n\n\nThe other problem is in the legend, which uses a logarithmic scale and includes breaks for 10k, 1M, 100M, and 10G, representing \\$10,000, \\$1 million, \\$100 million, and \\$10 billion in aid.\n\nThe issue is the \\$10 billion, which is abbreviated with \"G\".\n\nThis is happening because `d3.format()` uses SI ([Système international d'unités, or International System of Units](https://en.wikipedia.org/wiki/International_System_of_Units)) values for its numeric formats, which means that it uses [SI metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix). Those legend breaks, therefore, actually technically mean this: \n\n- 10k: 10 kilodollars\n- 1M: 1 megadollar\n- 100M: 100 megadollars\n- 10G: 10 gigadollars\n\nlol, I should start talking about big dollar amounts with these values (\"the 2022 US federal budget deficit was [1.4 teradollars](https://www.cbo.gov/publication/58888)\")\n\nThe first letters of many of these SI prefixes happen to line up with US-style large numbers:\n\n- In the US we already commonly use \"k\" for thousand\n- The initial \"m\" in \"mega\" aligns with \"million\"\n- The initial \"t\" in tera aligns with \"trillion\"\n\nBut \"giga\" doesn't align with \"billion\", hence the strange \"G\" here for dollar amounts.\n\n[People have requested](https://github.com/d3/d3-format/issues/71) that `d3-format` include an option for switching the abbreviation from G to B, but the developers haven't added it ([and probably won't](https://github.com/d3/d3-format/issues/71#issuecomment-515074256)). Instead, [a common recommended fix](https://talk.observablehq.com/t/how-do-i-make-the-billions-unit-show-as-b-instead-of-g-in-observable-plot/7560/2) is to replace all \"G\"s with \"B\"s:\n\n\n\n```{ojs}\nnumber_in_billions = 13840918291  // A big number I randomly typed\n\n// Billions of dollars instead of SI-style gigadollars\nd3.format(\"$.4s\")(number_in_billions).replace(\"G\", \"B\")\n```\n\n\n\nWe can add `format_aid_total()` and the `.replace(\"G\", \"B\")` tweak and fix the labels in our interactive map:\n\n\n\n```{ojs}\n//| column: body-outset\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3),\n      channels: {\n        Country: d => d.properties.name,\n      },\n      tip: {\n        format: {\n          Country: true,\n          fill: d => format_aid_total(d) //<<\n        }\n      }\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {\n    scheme: \"blues\",\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n    tickFormat: d => d3.format(\"$0.2s\")(d).replace(\"G\", \"B\") //<<\n  }\n})\n```\n\n\n\n## Some final tweaks\n\nWe're so close! Just a couple final incredibly minor changes:\n\n1. We'll boost the font size of the tooltip a little and increase the font size of the legend\n2. We'll switch from the built-in ColorBrewer `blues` palette to show how to use custom gradients, like [CARTOColors's PurpOr](https://carto.com/carto-colors/) sequential palette\n\n\n\n```{ojs}\n//| column: body-outset\n//| ht-pattern: \"//<<\"\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3),\n      channels: {\n        Country: d => d.properties.name,\n      },\n      tip: {\n        fontSize: 12, //<<\n        format: {\n          Country: true,\n          fill: d => format_aid_total(d)\n        }\n      }\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.15\n    })\n  ],\n  color: {\n    // scheme: \"blues\", //<<\n    range: [\"#f9ddda\", \"#f2b9c4\", \"#e597b9\", \"#ce78b3\", \"#ad5fad\", \"#834ba0\", \"#573b88\"], //<<\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n    tickFormat: d => d3.format(\"$0.2s\")(d).replace(\"G\", \"B\"),\n    style: { //<<\n      \"font-size\": \"14px\" //<<\n    } //<<\n  }\n})\n```\n\n\n\n\n# The full game: Complete final code\n\nThat final interactive map looks great! We could be even fancier with it by adding dropdowns for dynamically grabbing data for different years or different types of amounts (appropriations, allocations, etc.), or even filter by specific regions or countries. But we won't.\n\nThe different colors and data sources we've used are scattered throughout this post. To simplify things, here's the complete code all in one location. (This chunk doesn't actually run, since Observable gets mad if you create a new variable with the same name as one that already exists.)\n\n\n\n```{ojs}\n//| eval: false\n\nd3_geo = require(\"d3-geo\")\nd3_geo_projection = require(\"d3-geo-projection\")\n\n// ----------------------------------------------------------------------\n// Map stuff\n// ----------------------------------------------------------------------\nworld = FileAttachment(\"ne_110m_admin_0_countries.geojson\").json()\n\n// Antarctica's ISO3 code is ATA\nworld_sans_penguins = ({\n  type: \"FeatureCollection\",\n  features: world.features.filter(d => d.properties.iso_a3 !== \"ATA\")\n})\n\ninset_world = 10\nworld_map_width = 1000\nworld_map_height = 450\n\nworld_sans_penguins_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_world, inset_world],\n     [world_map_width - inset_world, world_map_height - inset_world]],\n    world_sans_penguins\n  )\n\n// ----------------------------------------------------------------------\n// Data stuff\n// ----------------------------------------------------------------------\nimport { DatasetteClient } from \"@ambassadors/datasette-client\"\n\naid_db = new DatasetteClient(\n  \"https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance\"\n)\n\nrecipient_countries = await aid_db.sql`\n  SELECT \"Country Code\", \"Country Name\", \"Region Name\", SUM(\"constant_amount\") AS total_constant_amount\n  FROM \"./us_foreign_aid_country\"\n  WHERE \n    \"Fiscal Year\" = '2023' \n    AND \"Transaction Type Name\" = 'Obligations' \n    AND \"Country Name\" NOT LIKE '%Region%' \n    AND \"Country Name\" != \"World\"\n  GROUP BY \"Country Code\", \"Country Name\", \"Region Name\"\n  ORDER BY total_constant_amount DESC;\n`\n\ncountry_totals = new Map(recipient_countries.map(d => [d[\"Country Code\"], d.total_constant_amount]))\n\nfunction format_aid_total(value) {\n  return value ? d3.format(\"$,d\")(value) : \"No aid\";\n}\n\n// ----------------------------------------------------------------------\n// Plot stuff\n// ----------------------------------------------------------------------\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d => country_totals.get(d.properties.iso_a3),\n      channels: {\n        Country: d => d.properties.name,\n      },\n      tip: {\n        fontSize: 12,\n        format: {\n          Country: true,\n          fill: d => format_aid_total(d)\n        }\n      }\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.15\n    })\n  ],\n  color: {\n    range: [\"#f9ddda\", \"#f2b9c4\", \"#e597b9\", \"#ce78b3\", \"#ad5fad\", \"#834ba0\", \"#573b88\"],\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n    tickFormat: d => d3.format(\"$0.2s\")(d).replace(\"G\", \"B\"),\n    style: {\n      \"font-size\": \"14px\" \n    }\n  }\n})\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}