{
  "hash": "88004a49b9ffbf8b363cd9af713ad7c9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to move Crimea from Russia to Ukraine in maps with R\"\ndate: 2025-02-13\ndescription: \"Natural Earth's de facto on-the-ground policy conflicts with de jure boundaries. Use {sf} and R to relocate parts of country shapes.\"\n\nimage: index_files/figure-html/plot-eastern-europe-50-1.png\ntwitter-card: \n    image: \"index_files/figure-html/plot-eastern-europe-50-1.png\"\nopen-graph: \n    image: \"index_files/figure-html/plot-eastern-europe-50-1.png\"\n\ncategories:\n  - r\n  - tidyverse\n  - ggplot\n  - ojs\n  - observable plot\n  - gis\n  - maps\n\nformat:\n  html:\n    include-in-header:\n      - text: |\n          <style type=\"text/css\">\n          div.sourceCode > pre.sourceCode.js::before {\n            content: 'Observable JS';\n            display: block;\n            text-align: left;\n            font-size: 1em;\n            margin-bottom: 7px;\n            border-bottom: #4c4c4c 1px solid;\n            padding-left: 4.25px;\n            padding-bottom: 5px;\n            color: #aaaaaa;\n          }\n\n          div.sourceCode > pre.sourceCode.r::before {\n            content: 'R';\n            display: block;\n            text-align: left;\n            font-size: 1em;\n            margin-bottom: 7px;\n            border-bottom: #4c4c4c 1px solid;\n            padding-left: 4.25px;\n            padding-bottom: 5px;\n            color: #aaaaaa;\n          }\n          </style>\n\ndoi: 10.59350/28kp0-nbq92\ncitation: true\n---\n\n\n\n\n\n## The Natural Earth Project\n\nThe [Natural Earth Project](https://www.naturalearthdata.com/downloads/) provides high quality public domain geographic data with all sorts of incredible detail, at three resolutions: high (1:10m), medium (1:50m), and low (1:110m). I use their data all the time in my own work and research, and [the {rnaturalearth} package](http://ropensci.github.io/rnaturalearth/) makes it really easy to get their data into R for immediate mapping. I mean, look at this!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(rnaturalearth)\n\n# Set some colors\nukr_blue <- \"#0057b7\"  # Blue from the Ukrainian flag\nukr_yellow <- \"#ffdd00\"  # Yellow from the Ukrainian flag\nrus_red <- \"#d62718\"  # Red from the Russian flag\n\nclr_ocean <- \"#d9f0ff\"\nclr_land <- \"#facba6\"\n\n# CARTOColors Prism (https://carto.com/carto-colors/)\ncarto_prism = c(\n  \"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \n  \"#E17C05\", \"#CC503E\", \"#94346E\", \"#6F4070\", \"#994E95\", \"#666666\"\n)\n\nne_countries(scale = 110) |> \n  filter(admin != \"Antarctica\") |> \n  ggplot() + \n  geom_sf(aes(fill = continent), color = \"white\", linewidth = 0.1) +\n  scale_fill_manual(values = carto_prism, guide = \"none\") +\n  coord_sf(crs = \"+proj=robin\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-natural-earth-world-map-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n### Natural Earth's *de facto* policy\n\n**Maps are intensely political things.** There are dozens of disputes over maps and land and territories (e.g., Palestine, Western Sahara, Northern Cyprus, Taiwan, Kashmir, etc.), and many UN member states don't recognize other UN member states ([Israel isn't recognized by many Arab states](https://en.wikipedia.org/wiki/International_recognition_of_Israel); [Pakistan doesn't recognize Armenia](https://en.wikipedia.org/wiki/Armenia%E2%80%93Pakistan_relations)).\n\nThe Natural Earth Project's [official policy for disputed territories](https://www.naturalearthdata.com/about/disputed-boundaries-policy/) is to reflect on-the-ground *de facto* [control over each piece of land](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-details/)^[[OpenStreetMap does this too](https://osmfoundation.org/w/images/d/d8/DisputedTerritoriesInformation.pdf).]:\n\n> Natural Earth Vector draws boundaries of sovereign states according to defacto status. We show who actually controls the situation on the ground. For instance, we show China and Taiwan as two separate states. But we show Palestine as part of Israel.\n\nThough [they claim that this *de facto* policy \"is rigorous and self consistent\"](https://www.naturalearthdata.com/about/disputed-boundaries-policy/), it gets them in trouble a lot. For instance, there are nearly [two dozen issues on GitHub](https://github.com/search?q=repo:nvkelso/natural-earth-vector+crimea&type=issues) about Crimea, which is [illegally occupied by Russia](https://en.wikipedia.org/wiki/Annexation_of_Crimea_by_the_Russian_Federation) but [*de jure* part of Ukraine](https://en.wikipedia.org/wiki/Russian_occupation_of_Crimea#Annexation). [There](https://github.com/nvkelso/natural-earth-vector/issues/391) [are](https://github.com/nvkelso/natural-earth-vector/issues/489) [huge](https://github.com/nvkelso/natural-earth-vector/issues/926) [debates](https://github.com/nvkelso/natural-earth-vector/issues/810) [over](https://github.com/nvkelso/natural-earth-vector/issues/812) the ethics of the *de facto* policy. \n\n::: {.callout-important}\n#### Treating the Natural Earth *de facto* policy as a *de facto* policy\n\n**I'm not weighing in on that policy here!** I don't super like it—it makes it really hard to map Palestine, for instance—but it is what it is. In this post I'm treating the *de facto* policy as the *de facto* situation of the data.\n:::\n\n### Natural Earth *de jure* points of view\n\nNatural Earth's solution for disputed territories is to [offer different options](https://github.com/nvkelso/natural-earth-vector/issues/391#issuecomment-890772203) to reflect country-specific *de jure* points of view. They offer [pre-built high resolution shapefiles for 31 different points of views](https://www.naturalearthdata.com/blog/admin-0-countries-point-of-views/), so it's possible to download data that reflect *de jure* boundaries for a bunch of different countries. Their other shapefiles [all have columns like `fclass_us`, `fclass_ua`, and so on](https://github.com/nvkelso/natural-earth-vector/blob/master/packages/Natural_Earth_quick_start/LOCALIZATION.md#setting-boundary-pov) for doing… something?… with the point of view. **I can't figure out how these columns work** beyond localization stuff (i.e. changing place names based on the point of view). The documentation doesn't say much about how to actually use these different points of view, and [pre-built medium and low resolution maps don't exist yet](https://github.com/nvkelso/natural-earth-vector/issues/875#issuecomment-1726400482).\n\nFor example, the US doesn't *de jure*-ily recognize the Russian occupation of Crimea, so if we [download the pre-built high resolution (10m) version of the world](https://www.naturalearthdata.com/blog/admin-0-countries-point-of-views/) from the US point of view, we can see Crimea as part of Ukraine (we have to [download this manually](https://www.naturalearthdata.com/blog/admin-0-countries-point-of-views/)—`rnaturalearth::ne_countries()` doesn't support POV files):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nworld_10_us <- read_sf(\"ne_10m_admin_0_countries_usa/ne_10m_admin_0_countries_usa.shp\")\n\nworld_10_us |> \n  filter(ADMIN == \"Ukraine\") |> \n  ggplot() +\n  geom_sf(fill = ukr_blue) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-ne-us10-ukraine-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nUnfortunately, the pre-built point-of-view datasets [only exist for the 10m high resolution data](https://github.com/nvkelso/natural-earth-vector/issues/875#issuecomment-1726400482). If we want to show medium or low resolution maps, we're stuck with the *de facto* version of the map, which means Crimea will be shown as part of Russia. Here's the low resolution version of Ukraine, with Crimea in Russia:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nworld <- ne_countries(scale = 110, type = \"map_units\")\n\nukraine <- world |> filter(admin == \"Ukraine\")\nrussia <- world |> filter(admin == \"Russia\")\n\nukraine_bbox <- ukraine |> \n  st_buffer(dist = 100000) |>  # Add 100,000 meter buffer around the country \n  st_bbox()\n\nggplot() +\n  geom_sf(data = world, fill = clr_land) +\n  geom_sf(data = russia, fill = rus_red) + \n  geom_sf(data = ukraine, fill = ukr_blue, color = ukr_yellow, linewidth = 2) + \n  coord_sf(\n    xlim = c(ukraine_bbox[\"xmin\"], ukraine_bbox[\"xmax\"]), \n    ylim = c(ukraine_bbox[\"ymin\"], ukraine_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-ne-110-crimea-in-russia-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## Relocating Crimea manually with R and {sf}\n\nNatural Earth's recommendation is to [\"mashup our countries and disputed areas themes to match their particular political outlook\"](https://www.naturalearthdata.com/about/disputed-boundaries-policy/), so we'll do that here. Though we won't use any of the point-of-view themes or features because I have no idea how to get those to work.\n\nInstead we'll manipulate the geometry data directly and move Crimea from the Russia shape to the Ukraine shape by extracting the Crimea POLYGON from Russia and merging it with Ukraine. \n\nThe actual geometric shapes for all the countries in `world` are MULTIPOLYGONs, or collections of POLYGON geometric objects. For instance, Russia is defined as a single MULTIPOLYGON: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrussia |> st_geometry()\n## Geometry set for 1 feature \n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: 41.15 xmax: 180 ymax: 81.25\n## Geodetic CRS:  WGS 84\n## MULTIPOLYGON (((178.7 71.1, 180 71.52, 180 70.8...\n```\n:::\n\n\n\nWe can split MULTIPOLYGONs into their component POLYGONs with `st_cast()`. Russia consists of 14 different shapes:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrussia_polygons <- russia |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\nrussia_polygons\n## Geometry set for 14 features \n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: 41.15 xmax: 180 ymax: 81.25\n## Geodetic CRS:  WGS 84\n## First 5 geometries:\n## POLYGON ((178.7 71.1, 180 71.52, 180 70.83, 178...\n## POLYGON ((49.1 46.4, 48.65 45.81, 47.68 45.64, ...\n## POLYGON ((93.78 81.02, 95.94 81.25, 97.88 80.75...\n## POLYGON ((102.8 79.28, 105.4 78.71, 105.1 78.31...\n## POLYGON ((138.8 76.14, 141.5 76.09, 145.1 75.56...\n```\n:::\n\n\n\nThe second one is the main Russia landmass:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(russia_polygons[2])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-main-russia-polygon-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nThe last one is the Crimean peninsula:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(russia_polygons[14])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-crimea-polygon-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### Identifying the Crimea POLYGON from a POINT\n\nThe only way I figured out what of these POLYGONs were was to plot them individually until I saw a recognizable shape. And if I use a different map (like the 50m or 10m resolution maps), there's no guarantee that Russia will have 14 POLYGONs or that the 14th one will be Crimea. We need a more reliable way to find the Crimea shape.\n\nOne way to do this is to create a POINT object based somewhere in Crimea and do some geometric set math to identify which Russian POLYGON contains it. The point [45°N 34°E](https://maps.app.goo.gl/iEkGZkrEpEcqTmZi7) happens to be in the middle of Crimea:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncrimea_point <- st_sfc(st_point(c(34, 45)), crs = st_crs(world))\n\nggplot() +\n  geom_sf(data = world, fill = clr_land) +\n  geom_sf(data = russia, fill = rus_red) + \n  geom_sf(data = ukraine, fill = ukr_blue, color = ukr_yellow, linewidth = 2) + \n  geom_sf(data = crimea_point) +\n  coord_sf(\n    xlim = c(ukraine_bbox[\"xmin\"], ukraine_bbox[\"xmax\"]), \n    ylim = c(ukraine_bbox[\"ymin\"], ukraine_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-crimea-point-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nWe can use it with `st_intersects()` to identify the Russia POLYGON that contains it:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Extract the Russia MULTIPOLYGON and convert it to polygons\nrussia_polygons <- world |> \n  filter(admin == \"Russia\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Extract the Russia polygon that has Crimea in it\ncrimea_polygon <- russia_polygons |>\n  keep(\\(x) st_intersects(x, crimea_point, sparse = FALSE))\n\n# This is the same as russia_polygons[14]\nplot(crimea_polygon)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-extracted-crimea-polygon-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### Extracting the Crimea POLYGON from Russia\n\nWe can then remove that polygon from Russia and recombine everything back into a MULTIPOLYGON. It works!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Remove Crimea from Russia\nnew_russia <- russia_polygons |>\n  discard(\\(x) any(st_equals(x, crimea_polygon, sparse = FALSE))) |> \n  st_combine() |> \n  st_cast(\"MULTIPOLYGON\")\n\nggplot() +\n  geom_sf(data = world, fill = clr_land) +\n  geom_sf(data = new_russia, fill = rus_red) + \n  geom_sf(data = ukraine, fill = ukr_blue, color = ukr_yellow, linewidth = 2) + \n  coord_sf(\n    xlim = c(ukraine_bbox[\"xmin\"], ukraine_bbox[\"xmax\"]), \n    ylim = c(ukraine_bbox[\"ymin\"], ukraine_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-crimea-removed-from-russia-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### Adding the Crimea POLYGON to Ukraine\n\nNext we need to merge `crimea_polygon` with Ukraine. We'll convert Ukraine to its component POLYGONs, combine those with Crimea, and recombine everything back to a MULTIPOLYGON. It also works!\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Extract the Ukraine MULTIPOLYGON and convert it to polygons\nukraine_polygons <- world |> \n  filter(admin == \"Ukraine\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Add Crimea to Ukraine\nnew_ukraine <- st_union(c(ukraine_polygons, crimea_polygon)) |>\n  st_cast(\"MULTIPOLYGON\")\n\nggplot() +\n  geom_sf(data = world, fill = clr_land) +\n  geom_sf(data = new_russia, fill = rus_red) + \n  geom_sf(data = new_ukraine, fill = ukr_blue, color = ukr_yellow, linewidth = 2) + \n  coord_sf(\n    xlim = c(ukraine_bbox[\"xmin\"], ukraine_bbox[\"xmax\"]), \n    ylim = c(ukraine_bbox[\"ymin\"], ukraine_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-crimea-added-to-ukraine-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### Updating Russia and Ukraine in the full data\n\nThe last step is to modify the full `world` dataset and replace the existing geometry values for the two countries with the updated boundaries:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nworld_un <- world |>\n  mutate(geometry = case_when(\n    admin == \"Ukraine\" ~ new_ukraine,\n    admin == \"Russia\" ~ new_russia,\n    .default = geometry\n  ))\n```\n:::\n\n\n\nNow that `world_un` has the corrected boundaries in it, it works like normal. Here's a map of Eastern Europe, colored by `mapcolor9` (a column that comes with Natural Earth data that lets you use 9 distinct colors to fill all countries without having bordering countries share colors). Crimea is in Ukraine now:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\neastern_eu_bbox <- ukraine |> \n  st_buffer(dist = 700000) |>  # Add 700,000 meter buffer around the country \n  st_bbox()\n\nggplot() +\n  geom_sf(data = world_un, aes(fill = factor(mapcolor9)), linewidth = 0.25, color = \"white\") +\n  scale_fill_manual(values = carto_prism, guide = \"none\") +\n  coord_sf(\n    xlim = c(eastern_eu_bbox[\"xmin\"], eastern_eu_bbox[\"xmax\"]), \n    ylim = c(eastern_eu_bbox[\"ymin\"], eastern_eu_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-eastern-europe-110-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### The whole game\n\nEverything above was fairly didactic, with illustrations at each intermediate step. Here's the whole process all in one place:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nworld_110 <- ne_countries(scale = 110, type = \"map_units\")\n\ncrimea_point_110 <- st_sfc(st_point(c(34, 45)), crs = st_crs(world_110))\n\n# Extract the Russia MULTIPOLYGON and convert it to polygons\nrussia_polygons_110 <- world_110 |> \n  filter(admin == \"Russia\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Extract the Russia polygon that has Crimea in it\ncrimea_polygon_110 <- russia_polygons_110 |>\n  keep(\\(x) st_intersects(x, crimea_point_110, sparse = FALSE))\n\n# Remove Crimea from Russia\nnew_russia_110 <- russia_polygons_110 |>\n  discard(\\(x) any(st_equals(x, crimea_polygon_110, sparse = FALSE))) |> \n  st_combine() |> \n  st_cast(\"MULTIPOLYGON\")\n\n# Extract the Ukraine MULTIPOLYGON and convert it to polygons\nukraine_polygons_110 <- world_110 |> \n  filter(admin == \"Ukraine\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Add Crimea to Ukraine\nnew_ukraine_110 <- st_union(c(ukraine_polygons_110, crimea_polygon_110)) |>\n  st_cast(\"MULTIPOLYGON\")\n\nworld_un_110 <- world_110 |>\n  mutate(geometry = case_when(\n    admin == \"Ukraine\" ~ new_ukraine_110,\n    admin == \"Russia\" ~ new_russia_110,\n    .default = geometry\n  ))\n```\n:::\n\n\n\n### Moving Crimea with medium resolution (50m) data\n\nThis same approach works for other map resolutions too, like 50m:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nworld_50 <- ne_countries(scale = 50, type = \"map_units\")\n\ncrimea_point_50 <- st_sfc(st_point(c(34, 45)), crs = st_crs(world_50))\n\n# Extract the Russia MULTIPOLYGON and convert it to polygons\nrussia_polygons_50 <- world_50 |> \n  filter(admin == \"Russia\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Extract the Russia polygon that has Crimea in it\ncrimea_polygon_50 <- russia_polygons_50 |>\n  keep(\\(x) st_intersects(x, crimea_point_50, sparse = FALSE))\n\n# Remove Crimea from Russia\nnew_russia_50 <- russia_polygons_50 |>\n  discard(\\(x) any(st_equals(x, crimea_polygon_50, sparse = FALSE))) |> \n  st_combine() |> \n  st_cast(\"MULTIPOLYGON\")\n\n# Extract the Ukraine MULTIPOLYGON and convert it to polygons\nukraine_polygons_50 <- world_50 |> \n  filter(admin == \"Ukraine\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Add Crimea to Ukraine\nnew_ukraine_50 <- st_union(c(ukraine_polygons_50, crimea_polygon_50)) |>\n  st_cast(\"MULTIPOLYGON\")\n\nworld_un_50 <- world_50 |>\n  mutate(geometry = case_when(\n    admin == \"Ukraine\" ~ new_ukraine_50,\n    admin == \"Russia\" ~ new_russia_50,\n    .default = geometry\n  ))\n```\n:::\n\n\n\nHere's a higher quality map of Eastern Europe with Crimea in Ukraine:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = world_un_50, aes(fill = factor(mapcolor9)), linewidth = 0.25, color = \"white\") +\n  scale_fill_manual(values = carto_prism, guide = \"none\") +\n  coord_sf(\n    xlim = c(eastern_eu_bbox[\"xmin\"], eastern_eu_bbox[\"xmax\"]), \n    ylim = c(eastern_eu_bbox[\"ymin\"], eastern_eu_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-eastern-europe-50-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## Using the adjusted Natural Earth data as GeoJSON in Observable JS\n\nThis updated shapefile works with Observable Plot too ([see here for more about how to make nice maps with Observable](https://www.andrewheiss.com/blog/2025/02/10/usaid-ojs-maps/)), but requires one strange tweak because of weird behavior with the GeoJSON file format.\n\n### Broken GeoJSON\n\nLet's export the adjusted geographic data to GeoJSON:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Save as geojson for Observable Plot\nst_write(\n  obj = world_un, \n  dsn = \"ne_110m_admin_0_countries_un_BROKEN.geojson\", \n  driver = \"GeoJSON\",\n  quiet = TRUE,\n  delete_dsn = TRUE  # Overwrite the existing .geojson if there is one\n)\n```\n:::\n\n\n\nAnd then load it with Observable JS:\n\n\n\n```{ojs}\n//| label: load-broken-data\n\nworld_broken = FileAttachment(\"ne_110m_admin_0_countries_un_BROKEN.geojson\").json()\n\nclr_ocean = \"#d9f0ff\"\nclr_land = \"#facba6\"\nukr_blue = \"#0057b7\"\nukr_yellow = \"#ffdd00\"\nrus_red = \"#d62718\"\n```\n\n\n\nAnd then plot it:\n\n\n\n```{ojs}\n//| label: plot-broken-world\n\nPlot.plot({\n  projection: \"equal-earth\",\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_broken, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    }) \n  ]\n})\n```\n\n\n\nlol what even. The new Ukraine shape seems to have broken boundaries that distort everything else in the map. Weirdly, Ukraine is filled with the ocean color while the rest of the globe—both the ocean and whatever countries didn't have their borders erased—is the color of land.\n\nLet's zoom in on just Ukraine:\n\n\n\n```{ojs}\n//| label: plot-broken-ukraine\n\nukraine = world_broken.features.find(d => d.properties.name === \"Ukraine\")\n\nPlot.plot({\n  projection: { \n    type: \"equal-earth\", \n    domain: ukraine, \n    inset: 50 \n  }, \n  width: 800, \n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_broken, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    }),\n    Plot.geo(ukraine, { fill: ukr_blue })\n  ]\n})\n```\n\n\n\n¯\\\\\\_(ツ)\\_/¯. Now Ukraine is the color of the ocean and the whole rest of the world is the dark blue of the Ukrainian flag. And it didn't zoom in at all.\n\n### GeoJSON and ↻ ↺ winding order ↻ ↺\n\nThis is a symptom of an issue with [GeoJSON winding order](https://macwright.com/2015/03/23/geojson-second-bite#winding). GeoJSON cares about the direction that country borders (and all LINESTRING elements) are drawn in. Exterior borders should be drawn counterclockwise; interior borders should be drawn clockwise. If a geographic shape doesn't follow this winding order, bad things happen. Specifically:\n\n> a shape that represents a tiny speck of land becomes inflated to represent the whole globe minus that tiny speck of land, the map fills with a uniform color, the local projection explodes. (via [\\@fil](https://observablehq.com/@fil/rewind))\n\nThat's exactly what's happening here. Somehow the winding order is getting reversed when we combine Ukraine with Crimea. {sf} itself doesn't care about winding order, so everything works fine within R; GeoJSON is picky about winding order, so things break.\n\nFixing it is tricky though! {sf} uses a bunch of different libraries behind the scenes to do its geographic calculations, including [GEOS](https://libgeos.org/) and [S2](http://s2geometry.io/), and they all have different approaches to polygon creation. Apparently [GEOS goes clockwise by default](https://github.com/r-spatial/sf/issues/2096#issuecomment-1426480037) while others go counterclockwise, or something. It should theoretically be possible to fix by adding `st_sfc(check_ring_dir = TRUE)` after making the new Ukraine shape:\n\n```{.r}\n# It would be cool if this worked but it doesn't :(\nnew_ukraine <- st_union(c(ukraine_polygons, crimea_polygon)) |>\n  st_sfc(check_ring_dir = TRUE) |> \n  st_cast(\"MULTIPOLYGON\")\n```\n\nBut that doesn't change anything ([nor does it work for this person at GitHub](https://github.com/r-spatial/sf/issues/2096#issuecomment-2269379942)).\n\n### Clean GeoJSON with correct winding order\n\nBUT there's another solution. We can force {sf} to *not* use the S2 library (which it uses by default, I guess?), since S2 seems go in the wrong direction. If we turn off S2 with `sf_use_s2(FALSE)`, make the new Ukraine shape, and then turn S2 back on with `sf_use_s2(TRUE)`, things work!\n\n```{.r}\n# Add Crimea to Ukraine\nsf_use_s2(FALSE)\nnew_ukraine_110 <- st_union(c(ukraine_polygons_110, crimea_polygon_110)) |>\n  st_cast(\"MULTIPOLYGON\")\nsf_use_s2(TRUE)\n```\n\nHere's the full process with the 110m map:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nworld_110 <- ne_countries(scale = 110, type = \"map_units\")\n\ncrimea_point_110 <- st_sfc(st_point(c(34, 45)), crs = st_crs(world_110))\n\n# Extract the Russia MULTIPOLYGON and convert it to polygons\nrussia_polygons_110 <- world_110 |> \n  filter(admin == \"Russia\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Extract the Russia polygon that has Crimea in it\ncrimea_polygon_110 <- russia_polygons_110 |>\n  keep(\\(x) st_intersects(x, crimea_point_110, sparse = FALSE))\n\n# Extract the Ukraine MULTIPOLYGON and convert it to polygons\nukraine_polygons_110 <- world_110 |> \n  filter(admin == \"Ukraine\") |> \n  st_geometry() |> \n  st_cast(\"POLYGON\")\n\n# Add Crimea to Ukraine\nsf_use_s2(FALSE)\n## Spherical geometry (s2) switched off\nnew_ukraine_110 <- st_union(c(ukraine_polygons_110, crimea_polygon_110)) |>\n  st_cast(\"MULTIPOLYGON\")\n## although coordinates are longitude/latitude, st_union assumes that they are planar\nsf_use_s2(TRUE)\n## Spherical geometry (s2) switched on\n\n# Remove Crimea from Russia\nnew_russia_110 <- russia_polygons_110 |>\n  discard(\\(x) any(st_equals(x, crimea_polygon_110, sparse = FALSE))) |> \n  st_combine() |> \n  st_cast(\"MULTIPOLYGON\")\n\n# Add the modified Russia and Ukraine to the main data\nworld_un_110_fixed <- world_110 |>\n  mutate(geometry = case_when(\n    admin == \"Ukraine\" ~ new_ukraine_110,\n    admin == \"Russia\" ~ new_russia_110,\n    .default = geometry\n  ))\n\n# Save as GeoJSON\nst_write(\n  obj = world_un_110_fixed, \n  dsn = \"ne_110m_admin_0_countries_un.geojson\", \n  driver = \"GeoJSON\",\n  quiet = TRUE,\n  delete_dsn = TRUE\n)\n```\n:::\n\n\n\nHere's the new world map with the the correct Ukraine:\n\n\n\n```{ojs}\n//| label: plot-fixed-world\n\nworld_fixed = FileAttachment(\"ne_110m_admin_0_countries_un.geojson\").json()\n\nPlot.plot({\n  projection: \"equal-earth\",\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_fixed, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    }) \n  ]\n})\n```\n\n\n\nWe can zoom in on Ukraine too:\n\n\n\n```{ojs}\n//| label: plot-fixed-ukraine\n\nukraine_good = world_fixed.features.find(d => d.properties.name === \"Ukraine\")\nrussia = world_fixed.features.find(d => d.properties.name === \"Russia\")\n\nPlot.plot({\n  projection: { \n    type: \"equal-earth\", \n    domain: ukraine_good, \n    inset: 50 \n  }, \n  width: 800, \n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_fixed, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    }),\n    Plot.geo(russia, { fill: rus_red }),\n    Plot.geo(ukraine_good, { \n      fill: ukr_blue, \n      stroke: ukr_yellow, \n      strokeWidth: 3\n    })\n  ]\n})\n```\n\n\n\n## Alternative data sources\n\nNatural Earth isn't the only source of geographic data online, and other sources use *de jure* borders instead of *de facto* borders, like these:\n\n### GISCO\n\nThe European Commission's Eurostat hosts the [Geographic Information System of the Commission (GISCO)](https://ec.europa.eu/eurostat/web/gisco), which provides GIS data for the EU. They offer global shapefiles that follow EU-based *de jure* borders. [The {giscoR} package](https://ropengov.github.io/giscoR/) provides a nice frontend for getting that data into R at 5 different resolutions (1:60m, 1:20m, 1:10m, 1:3m, and super detailed 1:1m!). It does not come with additional metadata for each country, though (i.e. there are no regional divisions, population values, map colors, names in other languages, and so on), so it requires some extra cleaning work if you want those details. For example, can add region information with [{countrycode}](https://vincentarelbundock.github.io/countrycode/):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(giscoR)\nlibrary(countrycode)\n\nworld_gisco <- gisco_get_countries(\n  year = \"2024\",\n  epsg = \"4326\",\n  resolution = \"60\"\n) |> \n  # Add World Bank regions\n  mutate(region = countrycode(ISO3_CODE, origin = \"iso3c\", destination = \"region\"))\n\nworld_gisco |> \n  filter(NAME_ENGL != \"Antarctica\") |> \n  ggplot() + \n  geom_sf(aes(fill = region), color = \"white\", linewidth = 0.1) +\n  scale_fill_manual(values = carto_prism, guide = \"none\") +\n  coord_sf(crs = \"+proj=robin\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-gisco-world-map-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nSince the EU doesn't *de jure*-ily recognize the Russian occupation of Crimea, Crimea is in Ukraine:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nukraine_gisco <- world_gisco |> filter(NAME_ENGL == \"Ukraine\")\nrussia_gisco <- world_gisco |> filter(NAME_ENGL == \"Russian Federation\")\n\nukraine_gisco_bbox <- ukraine_gisco |> \n  st_buffer(dist = 100000) |>  # Add 100,000 meter buffer around the country \n  st_bbox()\n\nggplot() +\n  geom_sf(data = world_gisco, fill = clr_land) +\n  geom_sf(data = russia_gisco, fill = rus_red) + \n  geom_sf(data = ukraine_gisco, fill = ukr_blue, color = ukr_yellow, linewidth = 2) + \n  coord_sf(\n    xlim = c(ukraine_gisco_bbox[\"xmin\"], ukraine_gisco_bbox[\"xmax\"]), \n    ylim = c(ukraine_gisco_bbox[\"ymin\"], ukraine_gisco_bbox[\"ymax\"])\n  ) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = clr_ocean))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-ukraine-gisco-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nIt's possible to use GISCO data with Observable too. We could load the data into R and clean it up there (like adding regions and other details) and the save it as GeoJSON, like we did with the Natural Earth data. \n\nOr we can grab the [original raw GeoJSON from Eurostat](https://gisco-services.ec.europa.eu/distribution/v2/countries/geojson/) directly. For example, here's the [raw 60M 2024 world map using the WGS84 (4326) projection](https://gisco-services.ec.europa.eu/distribution/v2/countries/geojson/CNTR_BN_60M_2024_4326.geojson) that we grabbed with `gisco_get_countries()` earlier.\n\n\n\n```{ojs}\n//| label: plot-ojs-gisco\n\nworld_gisco = await FileAttachment(\"https://gisco-services.ec.europa.eu/distribution/v2/countries/geojson/CNTR_RG_60M_2024_4326.geojson\").json()\n\nukraine_gisco = world_gisco.features.find(d => d.properties.NAME_ENGL === \"Ukraine\")\nrussia_gisco = world_gisco.features.find(d => d.properties.NAME_ENGL === \"Russian Federation\")\n\nPlot.plot({\n  projection: { \n    type: \"equal-earth\", \n    domain: ukraine_gisco, \n    inset: 50 \n  }, \n  width: 800, \n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_gisco, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    }),\n    Plot.geo(russia_gisco, { fill: rus_red }),\n    Plot.geo(ukraine_gisco, { \n      fill: ukr_blue, \n      stroke: ukr_yellow, \n      strokeWidth: 3\n    })\n  ]\n})\n```\n\n\n\n### Visionscarto\n\nThere are JSON-based map files created by [\\@fil at Observable](https://observablehq.com/user/@fil) as part of the [Visionscarto project](https://observablehq.com/@visionscarto/world-atlas-topojson).\n\nThey're based on Natural Earth, but with [some specific adjustments](https://observablehq.com/@visionscarto/world-atlas-topojson#cell-93) like adding Crimea to Ukraine, making Gaza a little bit bigger so that it doesn't get dropped at lower resolutions like 110m, and using UN boundaries for Western Sahara. \n\nLike GISCO, though, these don't have the additional columns that Natural Earth comes with (country names in a bunch of languages, region and continent designations, map coloring schemes, population and GDP estimates, etc.), and those would need to be added manually in R or Observable or whatever.\n\n\n\n```{ojs}\n//| label: plot-visionscarto\n\nimport {world110m} from \"@visionscarto/geo\"\n\ncountries110m = topojson.feature(world110m, world110m.objects.countries)\nukraine_visionscarto = countries110m.features.find(d => d.properties.name === \"Ukraine\")\nrussia_visionscarto = countries110m.features.find(d => d.properties.name === \"Russia\")\n\nPlot.plot({\n  projection: { \n    type: \"equal-earth\", \n    domain: ukraine_visionscarto, \n    inset: 50 \n  }, \n  width: 800, \n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(countries110m, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    }),\n    Plot.geo(russia_visionscarto, { fill: rus_red }),\n    Plot.geo(ukraine_visionscarto, { \n      fill: ukr_blue, \n      stroke: ukr_yellow, \n      strokeWidth: 3\n    })\n  ]\n})\n```\n\n\n\n### Less automatic sources\n\nThere are other sources too, but they require manual downloading:\n\n- [The geoBoundaries project](https://www.geoboundaries.org/), hosted by the [William & Mary geoLab](https://sites.google.com/view/wmgeolab/)\n- [The UN's Country Boundaries of the World hosted at the UN's Food and Agricultural Organization (FAO) site](https://data.apps.fao.org/catalog/iso/6aecaf08-c7d0-4e16-8778-b8dddae9da14)\n- [Opendatasoft's copy of the World Food Programme's World Administrative Boundaries shapefile](https://public.opendatasoft.com/explore/dataset/world-administrative-boundaries/map/?location=5,48.87917,30.25635&basemap=jawg.light&dataChart=eyJxdWVyaWVzIjpbeyJjb25maWciOnsiZGF0YXNldCI6IndvcmxkLWFkbWluaXN0cmF0aXZlLWJvdW5kYXJpZXMiLCJvcHRpb25zIjp7ImJhc2VtYXAiOiJqYXdnLmxpZ2h0IiwibG9jYXRpb24iOiI1LDQ1LjkwNTMsMzcuNzI3MDUifX0sImNoYXJ0cyI6W3siYWxpZ25Nb250aCI6dHJ1ZSwidHlwZSI6ImNvbHVtbiIsImZ1bmMiOiJDT1VOVCIsInNjaWVudGlmaWNEaXNwbGF5Ijp0cnVlLCJjb2xvciI6IiNGRjUxNUEifV0sInhBeGlzIjoic3RhdHVzIiwibWF4cG9pbnRzIjo1MCwic29ydCI6IiJ9XSwidGltZXNjYWxlIjoiIiwiZGlzcGxheUxlZ2VuZCI6dHJ1ZSwiYWxpZ25Nb250aCI6dHJ1ZX0%3D)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}